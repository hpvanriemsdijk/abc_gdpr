// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  application: (where?: ApplicationWhereInput) => Promise<boolean>;
  businessRole: (where?: BusinessRoleWhereInput) => Promise<boolean>;
  classification: (where?: ClassificationWhereInput) => Promise<boolean>;
  classificationLabel: (
    where?: ClassificationLabelWhereInput
  ) => Promise<boolean>;
  dataType: (where?: DataTypeWhereInput) => Promise<boolean>;
  organizationalUnit: (
    where?: OrganizationalUnitWhereInput
  ) => Promise<boolean>;
  organizationalUnitType: (
    where?: OrganizationalUnitTypeWhereInput
  ) => Promise<boolean>;
  person: (where?: PersonWhereInput) => Promise<boolean>;
  process: (where?: ProcessWhereInput) => Promise<boolean>;
  processingActivity: (
    where?: ProcessingActivityWhereInput
  ) => Promise<boolean>;
  qualityAttribute: (where?: QualityAttributeWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  application: (
    where: ApplicationWhereUniqueInput
  ) => ApplicationNullablePromise;
  applications: (args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Application>;
  applicationsConnection: (args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ApplicationConnectionPromise;
  businessRole: (
    where: BusinessRoleWhereUniqueInput
  ) => BusinessRoleNullablePromise;
  businessRoles: (args?: {
    where?: BusinessRoleWhereInput;
    orderBy?: BusinessRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BusinessRole>;
  businessRolesConnection: (args?: {
    where?: BusinessRoleWhereInput;
    orderBy?: BusinessRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BusinessRoleConnectionPromise;
  classification: (
    where: ClassificationWhereUniqueInput
  ) => ClassificationNullablePromise;
  classifications: (args?: {
    where?: ClassificationWhereInput;
    orderBy?: ClassificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Classification>;
  classificationsConnection: (args?: {
    where?: ClassificationWhereInput;
    orderBy?: ClassificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClassificationConnectionPromise;
  classificationLabel: (
    where: ClassificationLabelWhereUniqueInput
  ) => ClassificationLabelNullablePromise;
  classificationLabels: (args?: {
    where?: ClassificationLabelWhereInput;
    orderBy?: ClassificationLabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ClassificationLabel>;
  classificationLabelsConnection: (args?: {
    where?: ClassificationLabelWhereInput;
    orderBy?: ClassificationLabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClassificationLabelConnectionPromise;
  dataType: (where: DataTypeWhereUniqueInput) => DataTypeNullablePromise;
  dataTypes: (args?: {
    where?: DataTypeWhereInput;
    orderBy?: DataTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DataType>;
  dataTypesConnection: (args?: {
    where?: DataTypeWhereInput;
    orderBy?: DataTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DataTypeConnectionPromise;
  organizationalUnit: (
    where: OrganizationalUnitWhereUniqueInput
  ) => OrganizationalUnitNullablePromise;
  organizationalUnits: (args?: {
    where?: OrganizationalUnitWhereInput;
    orderBy?: OrganizationalUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OrganizationalUnit>;
  organizationalUnitsConnection: (args?: {
    where?: OrganizationalUnitWhereInput;
    orderBy?: OrganizationalUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrganizationalUnitConnectionPromise;
  organizationalUnitType: (
    where: OrganizationalUnitTypeWhereUniqueInput
  ) => OrganizationalUnitTypeNullablePromise;
  organizationalUnitTypes: (args?: {
    where?: OrganizationalUnitTypeWhereInput;
    orderBy?: OrganizationalUnitTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OrganizationalUnitType>;
  organizationalUnitTypesConnection: (args?: {
    where?: OrganizationalUnitTypeWhereInput;
    orderBy?: OrganizationalUnitTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrganizationalUnitTypeConnectionPromise;
  person: (where: PersonWhereUniqueInput) => PersonNullablePromise;
  persons: (args?: {
    where?: PersonWhereInput;
    orderBy?: PersonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Person>;
  personsConnection: (args?: {
    where?: PersonWhereInput;
    orderBy?: PersonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PersonConnectionPromise;
  process: (where: ProcessWhereUniqueInput) => ProcessNullablePromise;
  processes: (args?: {
    where?: ProcessWhereInput;
    orderBy?: ProcessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Process>;
  processesConnection: (args?: {
    where?: ProcessWhereInput;
    orderBy?: ProcessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProcessConnectionPromise;
  processingActivity: (
    where: ProcessingActivityWhereUniqueInput
  ) => ProcessingActivityNullablePromise;
  processingActivities: (args?: {
    where?: ProcessingActivityWhereInput;
    orderBy?: ProcessingActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProcessingActivity>;
  processingActivitiesConnection: (args?: {
    where?: ProcessingActivityWhereInput;
    orderBy?: ProcessingActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProcessingActivityConnectionPromise;
  qualityAttribute: (
    where: QualityAttributeWhereUniqueInput
  ) => QualityAttributeNullablePromise;
  qualityAttributes: (args?: {
    where?: QualityAttributeWhereInput;
    orderBy?: QualityAttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QualityAttribute>;
  qualityAttributesConnection: (args?: {
    where?: QualityAttributeWhereInput;
    orderBy?: QualityAttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QualityAttributeConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createApplication: (data: ApplicationCreateInput) => ApplicationPromise;
  updateApplication: (args: {
    data: ApplicationUpdateInput;
    where: ApplicationWhereUniqueInput;
  }) => ApplicationPromise;
  updateManyApplications: (args: {
    data: ApplicationUpdateManyMutationInput;
    where?: ApplicationWhereInput;
  }) => BatchPayloadPromise;
  upsertApplication: (args: {
    where: ApplicationWhereUniqueInput;
    create: ApplicationCreateInput;
    update: ApplicationUpdateInput;
  }) => ApplicationPromise;
  deleteApplication: (where: ApplicationWhereUniqueInput) => ApplicationPromise;
  deleteManyApplications: (
    where?: ApplicationWhereInput
  ) => BatchPayloadPromise;
  createBusinessRole: (data: BusinessRoleCreateInput) => BusinessRolePromise;
  updateBusinessRole: (args: {
    data: BusinessRoleUpdateInput;
    where: BusinessRoleWhereUniqueInput;
  }) => BusinessRolePromise;
  updateManyBusinessRoles: (args: {
    data: BusinessRoleUpdateManyMutationInput;
    where?: BusinessRoleWhereInput;
  }) => BatchPayloadPromise;
  upsertBusinessRole: (args: {
    where: BusinessRoleWhereUniqueInput;
    create: BusinessRoleCreateInput;
    update: BusinessRoleUpdateInput;
  }) => BusinessRolePromise;
  deleteBusinessRole: (
    where: BusinessRoleWhereUniqueInput
  ) => BusinessRolePromise;
  deleteManyBusinessRoles: (
    where?: BusinessRoleWhereInput
  ) => BatchPayloadPromise;
  createClassification: (
    data: ClassificationCreateInput
  ) => ClassificationPromise;
  updateClassification: (args: {
    data: ClassificationUpdateInput;
    where: ClassificationWhereUniqueInput;
  }) => ClassificationPromise;
  upsertClassification: (args: {
    where: ClassificationWhereUniqueInput;
    create: ClassificationCreateInput;
    update: ClassificationUpdateInput;
  }) => ClassificationPromise;
  deleteClassification: (
    where: ClassificationWhereUniqueInput
  ) => ClassificationPromise;
  deleteManyClassifications: (
    where?: ClassificationWhereInput
  ) => BatchPayloadPromise;
  createClassificationLabel: (
    data: ClassificationLabelCreateInput
  ) => ClassificationLabelPromise;
  updateClassificationLabel: (args: {
    data: ClassificationLabelUpdateInput;
    where: ClassificationLabelWhereUniqueInput;
  }) => ClassificationLabelPromise;
  updateManyClassificationLabels: (args: {
    data: ClassificationLabelUpdateManyMutationInput;
    where?: ClassificationLabelWhereInput;
  }) => BatchPayloadPromise;
  upsertClassificationLabel: (args: {
    where: ClassificationLabelWhereUniqueInput;
    create: ClassificationLabelCreateInput;
    update: ClassificationLabelUpdateInput;
  }) => ClassificationLabelPromise;
  deleteClassificationLabel: (
    where: ClassificationLabelWhereUniqueInput
  ) => ClassificationLabelPromise;
  deleteManyClassificationLabels: (
    where?: ClassificationLabelWhereInput
  ) => BatchPayloadPromise;
  createDataType: (data: DataTypeCreateInput) => DataTypePromise;
  updateDataType: (args: {
    data: DataTypeUpdateInput;
    where: DataTypeWhereUniqueInput;
  }) => DataTypePromise;
  updateManyDataTypes: (args: {
    data: DataTypeUpdateManyMutationInput;
    where?: DataTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertDataType: (args: {
    where: DataTypeWhereUniqueInput;
    create: DataTypeCreateInput;
    update: DataTypeUpdateInput;
  }) => DataTypePromise;
  deleteDataType: (where: DataTypeWhereUniqueInput) => DataTypePromise;
  deleteManyDataTypes: (where?: DataTypeWhereInput) => BatchPayloadPromise;
  createOrganizationalUnit: (
    data: OrganizationalUnitCreateInput
  ) => OrganizationalUnitPromise;
  updateOrganizationalUnit: (args: {
    data: OrganizationalUnitUpdateInput;
    where: OrganizationalUnitWhereUniqueInput;
  }) => OrganizationalUnitPromise;
  updateManyOrganizationalUnits: (args: {
    data: OrganizationalUnitUpdateManyMutationInput;
    where?: OrganizationalUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertOrganizationalUnit: (args: {
    where: OrganizationalUnitWhereUniqueInput;
    create: OrganizationalUnitCreateInput;
    update: OrganizationalUnitUpdateInput;
  }) => OrganizationalUnitPromise;
  deleteOrganizationalUnit: (
    where: OrganizationalUnitWhereUniqueInput
  ) => OrganizationalUnitPromise;
  deleteManyOrganizationalUnits: (
    where?: OrganizationalUnitWhereInput
  ) => BatchPayloadPromise;
  createOrganizationalUnitType: (
    data: OrganizationalUnitTypeCreateInput
  ) => OrganizationalUnitTypePromise;
  updateOrganizationalUnitType: (args: {
    data: OrganizationalUnitTypeUpdateInput;
    where: OrganizationalUnitTypeWhereUniqueInput;
  }) => OrganizationalUnitTypePromise;
  updateManyOrganizationalUnitTypes: (args: {
    data: OrganizationalUnitTypeUpdateManyMutationInput;
    where?: OrganizationalUnitTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertOrganizationalUnitType: (args: {
    where: OrganizationalUnitTypeWhereUniqueInput;
    create: OrganizationalUnitTypeCreateInput;
    update: OrganizationalUnitTypeUpdateInput;
  }) => OrganizationalUnitTypePromise;
  deleteOrganizationalUnitType: (
    where: OrganizationalUnitTypeWhereUniqueInput
  ) => OrganizationalUnitTypePromise;
  deleteManyOrganizationalUnitTypes: (
    where?: OrganizationalUnitTypeWhereInput
  ) => BatchPayloadPromise;
  createPerson: (data: PersonCreateInput) => PersonPromise;
  updatePerson: (args: {
    data: PersonUpdateInput;
    where: PersonWhereUniqueInput;
  }) => PersonPromise;
  updateManyPersons: (args: {
    data: PersonUpdateManyMutationInput;
    where?: PersonWhereInput;
  }) => BatchPayloadPromise;
  upsertPerson: (args: {
    where: PersonWhereUniqueInput;
    create: PersonCreateInput;
    update: PersonUpdateInput;
  }) => PersonPromise;
  deletePerson: (where: PersonWhereUniqueInput) => PersonPromise;
  deleteManyPersons: (where?: PersonWhereInput) => BatchPayloadPromise;
  createProcess: (data: ProcessCreateInput) => ProcessPromise;
  updateProcess: (args: {
    data: ProcessUpdateInput;
    where: ProcessWhereUniqueInput;
  }) => ProcessPromise;
  updateManyProcesses: (args: {
    data: ProcessUpdateManyMutationInput;
    where?: ProcessWhereInput;
  }) => BatchPayloadPromise;
  upsertProcess: (args: {
    where: ProcessWhereUniqueInput;
    create: ProcessCreateInput;
    update: ProcessUpdateInput;
  }) => ProcessPromise;
  deleteProcess: (where: ProcessWhereUniqueInput) => ProcessPromise;
  deleteManyProcesses: (where?: ProcessWhereInput) => BatchPayloadPromise;
  createProcessingActivity: (
    data: ProcessingActivityCreateInput
  ) => ProcessingActivityPromise;
  updateProcessingActivity: (args: {
    data: ProcessingActivityUpdateInput;
    where: ProcessingActivityWhereUniqueInput;
  }) => ProcessingActivityPromise;
  updateManyProcessingActivities: (args: {
    data: ProcessingActivityUpdateManyMutationInput;
    where?: ProcessingActivityWhereInput;
  }) => BatchPayloadPromise;
  upsertProcessingActivity: (args: {
    where: ProcessingActivityWhereUniqueInput;
    create: ProcessingActivityCreateInput;
    update: ProcessingActivityUpdateInput;
  }) => ProcessingActivityPromise;
  deleteProcessingActivity: (
    where: ProcessingActivityWhereUniqueInput
  ) => ProcessingActivityPromise;
  deleteManyProcessingActivities: (
    where?: ProcessingActivityWhereInput
  ) => BatchPayloadPromise;
  createQualityAttribute: (
    data: QualityAttributeCreateInput
  ) => QualityAttributePromise;
  updateQualityAttribute: (args: {
    data: QualityAttributeUpdateInput;
    where: QualityAttributeWhereUniqueInput;
  }) => QualityAttributePromise;
  updateManyQualityAttributes: (args: {
    data: QualityAttributeUpdateManyMutationInput;
    where?: QualityAttributeWhereInput;
  }) => BatchPayloadPromise;
  upsertQualityAttribute: (args: {
    where: QualityAttributeWhereUniqueInput;
    create: QualityAttributeCreateInput;
    update: QualityAttributeUpdateInput;
  }) => QualityAttributePromise;
  deleteQualityAttribute: (
    where: QualityAttributeWhereUniqueInput
  ) => QualityAttributePromise;
  deleteManyQualityAttributes: (
    where?: QualityAttributeWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  application: (
    where?: ApplicationSubscriptionWhereInput
  ) => ApplicationSubscriptionPayloadSubscription;
  businessRole: (
    where?: BusinessRoleSubscriptionWhereInput
  ) => BusinessRoleSubscriptionPayloadSubscription;
  classification: (
    where?: ClassificationSubscriptionWhereInput
  ) => ClassificationSubscriptionPayloadSubscription;
  classificationLabel: (
    where?: ClassificationLabelSubscriptionWhereInput
  ) => ClassificationLabelSubscriptionPayloadSubscription;
  dataType: (
    where?: DataTypeSubscriptionWhereInput
  ) => DataTypeSubscriptionPayloadSubscription;
  organizationalUnit: (
    where?: OrganizationalUnitSubscriptionWhereInput
  ) => OrganizationalUnitSubscriptionPayloadSubscription;
  organizationalUnitType: (
    where?: OrganizationalUnitTypeSubscriptionWhereInput
  ) => OrganizationalUnitTypeSubscriptionPayloadSubscription;
  person: (
    where?: PersonSubscriptionWhereInput
  ) => PersonSubscriptionPayloadSubscription;
  process: (
    where?: ProcessSubscriptionWhereInput
  ) => ProcessSubscriptionPayloadSubscription;
  processingActivity: (
    where?: ProcessingActivitySubscriptionWhereInput
  ) => ProcessingActivitySubscriptionPayloadSubscription;
  qualityAttribute: (
    where?: QualityAttributeSubscriptionWhereInput
  ) => QualityAttributeSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DataTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC";

export type CLASSIFICATIONOBJECT = "DATA" | "APPLICATION";

export type RACI = "RESPONDSABLE" | "ACCOUNTABLE" | "CONSULTED" | "INFORMED";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "active_ASC"
  | "active_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ApplicationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "alias_ASC"
  | "alias_DESC"
  | "description_ASC"
  | "description_DESC";

export type PersonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "surname_ASC"
  | "surname_DESC";

export type PERMISSION = "ADMIN" | "AUDIT";

export type ClassificationLabelOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "score_ASC"
  | "score_DESC"
  | "label_ASC"
  | "label_DESC"
  | "criteria_ASC"
  | "criteria_DESC";

export type ProcessingActivityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "purpose_ASC"
  | "purpose_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrganizationalUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProcessOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BusinessRoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "raciPrivacy_ASC"
  | "raciPrivacy_DESC"
  | "raciSecurity_ASC"
  | "raciSecurity_DESC"
  | "raciFinancial_ASC"
  | "raciFinancial_DESC"
  | "raciExecutive_ASC"
  | "raciExecutive_DESC";

export type ClassificationOrderByInput = "id_ASC" | "id_DESC";

export type OrganizationalUnitTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "reportingUnit_ASC"
  | "reportingUnit_DESC";

export type QualityAttributeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "appliesToObject_ASC"
  | "appliesToObject_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface BusinessRoleUpdateOneWithoutAppBusinessOwnerInput {
  create?: Maybe<BusinessRoleCreateWithoutAppBusinessOwnerInput>;
  update?: Maybe<BusinessRoleUpdateWithoutAppBusinessOwnerDataInput>;
  upsert?: Maybe<BusinessRoleUpsertWithoutAppBusinessOwnerInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BusinessRoleWhereUniqueInput>;
}

export type ApplicationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OrganizationalUnitUpdateWithoutProcessesDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  children?: Maybe<OrganizationalUnitUpdateManyWithoutParentInput>;
  parent?: Maybe<OrganizationalUnitUpdateOneWithoutChildrenInput>;
  businessRoles?: Maybe<BusinessRoleUpdateManyWithoutOrganizationalUnitInput>;
  organizationalUnitType?: Maybe<
    OrganizationalUnitTypeUpdateOneWithoutOrganizationalUnitInput
  >;
}

export interface OrganizationalUnitTypeCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  reportingUnit?: Maybe<Boolean>;
  organizationalUnit?: Maybe<
    OrganizationalUnitCreateManyWithoutOrganizationalUnitTypeInput
  >;
}

export interface OrganizationalUnitUpdateManyWithoutParentInput {
  create?: Maybe<
    | OrganizationalUnitCreateWithoutParentInput[]
    | OrganizationalUnitCreateWithoutParentInput
  >;
  delete?: Maybe<
    OrganizationalUnitWhereUniqueInput[] | OrganizationalUnitWhereUniqueInput
  >;
  connect?: Maybe<
    OrganizationalUnitWhereUniqueInput[] | OrganizationalUnitWhereUniqueInput
  >;
  set?: Maybe<
    OrganizationalUnitWhereUniqueInput[] | OrganizationalUnitWhereUniqueInput
  >;
  disconnect?: Maybe<
    OrganizationalUnitWhereUniqueInput[] | OrganizationalUnitWhereUniqueInput
  >;
  update?: Maybe<
    | OrganizationalUnitUpdateWithWhereUniqueWithoutParentInput[]
    | OrganizationalUnitUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | OrganizationalUnitUpsertWithWhereUniqueWithoutParentInput[]
    | OrganizationalUnitUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<
    OrganizationalUnitScalarWhereInput[] | OrganizationalUnitScalarWhereInput
  >;
  updateMany?: Maybe<
    | OrganizationalUnitUpdateManyWithWhereNestedInput[]
    | OrganizationalUnitUpdateManyWithWhereNestedInput
  >;
}

export interface OrganizationalUnitUpdateOneRequiredWithoutBusinessRolesInput {
  create?: Maybe<OrganizationalUnitCreateWithoutBusinessRolesInput>;
  update?: Maybe<OrganizationalUnitUpdateWithoutBusinessRolesDataInput>;
  upsert?: Maybe<OrganizationalUnitUpsertWithoutBusinessRolesInput>;
  connect?: Maybe<OrganizationalUnitWhereUniqueInput>;
}

export interface OrganizationalUnitUpdateWithWhereUniqueWithoutParentInput {
  where: OrganizationalUnitWhereUniqueInput;
  data: OrganizationalUnitUpdateWithoutParentDataInput;
}

export interface OrganizationalUnitTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  reportingUnit?: Maybe<Boolean>;
  reportingUnit_not?: Maybe<Boolean>;
  organizationalUnit_every?: Maybe<OrganizationalUnitWhereInput>;
  organizationalUnit_some?: Maybe<OrganizationalUnitWhereInput>;
  organizationalUnit_none?: Maybe<OrganizationalUnitWhereInput>;
  AND?: Maybe<
    OrganizationalUnitTypeWhereInput[] | OrganizationalUnitTypeWhereInput
  >;
  OR?: Maybe<
    OrganizationalUnitTypeWhereInput[] | OrganizationalUnitTypeWhereInput
  >;
  NOT?: Maybe<
    OrganizationalUnitTypeWhereInput[] | OrganizationalUnitTypeWhereInput
  >;
}

export interface OrganizationalUnitUpdateWithoutParentDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  children?: Maybe<OrganizationalUnitUpdateManyWithoutParentInput>;
  processes?: Maybe<ProcessUpdateManyWithoutOrganizationalUnitInput>;
  businessRoles?: Maybe<BusinessRoleUpdateManyWithoutOrganizationalUnitInput>;
  organizationalUnitType?: Maybe<
    OrganizationalUnitTypeUpdateOneWithoutOrganizationalUnitInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface ProcessUpdateManyWithoutOrganizationalUnitInput {
  create?: Maybe<
    | ProcessCreateWithoutOrganizationalUnitInput[]
    | ProcessCreateWithoutOrganizationalUnitInput
  >;
  delete?: Maybe<ProcessWhereUniqueInput[] | ProcessWhereUniqueInput>;
  connect?: Maybe<ProcessWhereUniqueInput[] | ProcessWhereUniqueInput>;
  set?: Maybe<ProcessWhereUniqueInput[] | ProcessWhereUniqueInput>;
  disconnect?: Maybe<ProcessWhereUniqueInput[] | ProcessWhereUniqueInput>;
  update?: Maybe<
    | ProcessUpdateWithWhereUniqueWithoutOrganizationalUnitInput[]
    | ProcessUpdateWithWhereUniqueWithoutOrganizationalUnitInput
  >;
  upsert?: Maybe<
    | ProcessUpsertWithWhereUniqueWithoutOrganizationalUnitInput[]
    | ProcessUpsertWithWhereUniqueWithoutOrganizationalUnitInput
  >;
  deleteMany?: Maybe<ProcessScalarWhereInput[] | ProcessScalarWhereInput>;
  updateMany?: Maybe<
    | ProcessUpdateManyWithWhereNestedInput[]
    | ProcessUpdateManyWithWhereNestedInput
  >;
}

export interface ProcessingActivitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProcessingActivityWhereInput>;
  AND?: Maybe<
    | ProcessingActivitySubscriptionWhereInput[]
    | ProcessingActivitySubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProcessingActivitySubscriptionWhereInput[]
    | ProcessingActivitySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProcessingActivitySubscriptionWhereInput[]
    | ProcessingActivitySubscriptionWhereInput
  >;
}

export interface ProcessUpdateWithWhereUniqueWithoutOrganizationalUnitInput {
  where: ProcessWhereUniqueInput;
  data: ProcessUpdateWithoutOrganizationalUnitDataInput;
}

export interface ApplicationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  processingActivities_every?: Maybe<ProcessingActivityWhereInput>;
  processingActivities_some?: Maybe<ProcessingActivityWhereInput>;
  processingActivities_none?: Maybe<ProcessingActivityWhereInput>;
  dataType_every?: Maybe<DataTypeWhereInput>;
  dataType_some?: Maybe<DataTypeWhereInput>;
  dataType_none?: Maybe<DataTypeWhereInput>;
  businessOwner?: Maybe<BusinessRoleWhereInput>;
  itOwner?: Maybe<BusinessRoleWhereInput>;
  securityAdministrator?: Maybe<BusinessRoleWhereInput>;
  AND?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
  OR?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
  NOT?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
}

export interface ProcessUpdateWithoutOrganizationalUnitDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  processingActivities?: Maybe<ProcessingActivityUpdateManyWithoutProcessInput>;
  processOwner?: Maybe<BusinessRoleUpdateOneWithoutProcessInput>;
}

export interface PersonSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PersonWhereInput>;
  AND?: Maybe<PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput>;
  OR?: Maybe<PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput>;
  NOT?: Maybe<PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput>;
}

export interface ProcessingActivityUpdateManyWithoutProcessInput {
  create?: Maybe<
    | ProcessingActivityCreateWithoutProcessInput[]
    | ProcessingActivityCreateWithoutProcessInput
  >;
  delete?: Maybe<
    ProcessingActivityWhereUniqueInput[] | ProcessingActivityWhereUniqueInput
  >;
  connect?: Maybe<
    ProcessingActivityWhereUniqueInput[] | ProcessingActivityWhereUniqueInput
  >;
  set?: Maybe<
    ProcessingActivityWhereUniqueInput[] | ProcessingActivityWhereUniqueInput
  >;
  disconnect?: Maybe<
    ProcessingActivityWhereUniqueInput[] | ProcessingActivityWhereUniqueInput
  >;
  update?: Maybe<
    | ProcessingActivityUpdateWithWhereUniqueWithoutProcessInput[]
    | ProcessingActivityUpdateWithWhereUniqueWithoutProcessInput
  >;
  upsert?: Maybe<
    | ProcessingActivityUpsertWithWhereUniqueWithoutProcessInput[]
    | ProcessingActivityUpsertWithWhereUniqueWithoutProcessInput
  >;
  deleteMany?: Maybe<
    ProcessingActivityScalarWhereInput[] | ProcessingActivityScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProcessingActivityUpdateManyWithWhereNestedInput[]
    | ProcessingActivityUpdateManyWithWhereNestedInput
  >;
}

export interface OrganizationalUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrganizationalUnitWhereInput>;
  AND?: Maybe<
    | OrganizationalUnitSubscriptionWhereInput[]
    | OrganizationalUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    | OrganizationalUnitSubscriptionWhereInput[]
    | OrganizationalUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | OrganizationalUnitSubscriptionWhereInput[]
    | OrganizationalUnitSubscriptionWhereInput
  >;
}

export interface ProcessingActivityUpdateWithWhereUniqueWithoutProcessInput {
  where: ProcessingActivityWhereUniqueInput;
  data: ProcessingActivityUpdateWithoutProcessDataInput;
}

export interface PersonWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  surname?: Maybe<String>;
  surname_not?: Maybe<String>;
  surname_in?: Maybe<String[] | String>;
  surname_not_in?: Maybe<String[] | String>;
  surname_lt?: Maybe<String>;
  surname_lte?: Maybe<String>;
  surname_gt?: Maybe<String>;
  surname_gte?: Maybe<String>;
  surname_contains?: Maybe<String>;
  surname_not_contains?: Maybe<String>;
  surname_starts_with?: Maybe<String>;
  surname_not_starts_with?: Maybe<String>;
  surname_ends_with?: Maybe<String>;
  surname_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  roles_every?: Maybe<BusinessRoleWhereInput>;
  roles_some?: Maybe<BusinessRoleWhereInput>;
  roles_none?: Maybe<BusinessRoleWhereInput>;
  AND?: Maybe<PersonWhereInput[] | PersonWhereInput>;
  OR?: Maybe<PersonWhereInput[] | PersonWhereInput>;
  NOT?: Maybe<PersonWhereInput[] | PersonWhereInput>;
}

export interface ProcessingActivityUpdateWithoutProcessDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  purpose?: Maybe<String>;
  applications?: Maybe<ApplicationUpdateManyWithoutProcessingActivitiesInput>;
}

export interface BusinessRoleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciPrivacy_not?: Maybe<RACI>;
  raciPrivacy_in?: Maybe<RACI[] | RACI>;
  raciPrivacy_not_in?: Maybe<RACI[] | RACI>;
  raciSecurity?: Maybe<RACI>;
  raciSecurity_not?: Maybe<RACI>;
  raciSecurity_in?: Maybe<RACI[] | RACI>;
  raciSecurity_not_in?: Maybe<RACI[] | RACI>;
  raciFinancial?: Maybe<RACI>;
  raciFinancial_not?: Maybe<RACI>;
  raciFinancial_in?: Maybe<RACI[] | RACI>;
  raciFinancial_not_in?: Maybe<RACI[] | RACI>;
  raciExecutive?: Maybe<RACI>;
  raciExecutive_not?: Maybe<RACI>;
  raciExecutive_in?: Maybe<RACI[] | RACI>;
  raciExecutive_not_in?: Maybe<RACI[] | RACI>;
  person?: Maybe<PersonWhereInput>;
  organizationalUnit?: Maybe<OrganizationalUnitWhereInput>;
  process_every?: Maybe<ProcessWhereInput>;
  process_some?: Maybe<ProcessWhereInput>;
  process_none?: Maybe<ProcessWhereInput>;
  appBusinessOwner_every?: Maybe<ApplicationWhereInput>;
  appBusinessOwner_some?: Maybe<ApplicationWhereInput>;
  appBusinessOwner_none?: Maybe<ApplicationWhereInput>;
  appItOwner_every?: Maybe<ApplicationWhereInput>;
  appItOwner_some?: Maybe<ApplicationWhereInput>;
  appItOwner_none?: Maybe<ApplicationWhereInput>;
  appSecAdmin_every?: Maybe<ApplicationWhereInput>;
  appSecAdmin_some?: Maybe<ApplicationWhereInput>;
  appSecAdmin_none?: Maybe<ApplicationWhereInput>;
  AND?: Maybe<BusinessRoleWhereInput[] | BusinessRoleWhereInput>;
  OR?: Maybe<BusinessRoleWhereInput[] | BusinessRoleWhereInput>;
  NOT?: Maybe<BusinessRoleWhereInput[] | BusinessRoleWhereInput>;
}

export interface ApplicationUpdateManyWithoutProcessingActivitiesInput {
  create?: Maybe<
    | ApplicationCreateWithoutProcessingActivitiesInput[]
    | ApplicationCreateWithoutProcessingActivitiesInput
  >;
  delete?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  set?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  disconnect?: Maybe<
    ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput
  >;
  update?: Maybe<
    | ApplicationUpdateWithWhereUniqueWithoutProcessingActivitiesInput[]
    | ApplicationUpdateWithWhereUniqueWithoutProcessingActivitiesInput
  >;
  upsert?: Maybe<
    | ApplicationUpsertWithWhereUniqueWithoutProcessingActivitiesInput[]
    | ApplicationUpsertWithWhereUniqueWithoutProcessingActivitiesInput
  >;
  deleteMany?: Maybe<
    ApplicationScalarWhereInput[] | ApplicationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput
  >;
}

export interface OrganizationalUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  children_every?: Maybe<OrganizationalUnitWhereInput>;
  children_some?: Maybe<OrganizationalUnitWhereInput>;
  children_none?: Maybe<OrganizationalUnitWhereInput>;
  parent?: Maybe<OrganizationalUnitWhereInput>;
  processes_every?: Maybe<ProcessWhereInput>;
  processes_some?: Maybe<ProcessWhereInput>;
  processes_none?: Maybe<ProcessWhereInput>;
  businessRoles_every?: Maybe<BusinessRoleWhereInput>;
  businessRoles_some?: Maybe<BusinessRoleWhereInput>;
  businessRoles_none?: Maybe<BusinessRoleWhereInput>;
  organizationalUnitType?: Maybe<OrganizationalUnitTypeWhereInput>;
  AND?: Maybe<OrganizationalUnitWhereInput[] | OrganizationalUnitWhereInput>;
  OR?: Maybe<OrganizationalUnitWhereInput[] | OrganizationalUnitWhereInput>;
  NOT?: Maybe<OrganizationalUnitWhereInput[] | OrganizationalUnitWhereInput>;
}

export interface ApplicationUpdateWithWhereUniqueWithoutProcessingActivitiesInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutProcessingActivitiesDataInput;
}

export interface BusinessRoleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BusinessRoleWhereInput>;
  AND?: Maybe<
    BusinessRoleSubscriptionWhereInput[] | BusinessRoleSubscriptionWhereInput
  >;
  OR?: Maybe<
    BusinessRoleSubscriptionWhereInput[] | BusinessRoleSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BusinessRoleSubscriptionWhereInput[] | BusinessRoleSubscriptionWhereInput
  >;
}

export interface ApplicationUpdateWithoutProcessingActivitiesDataInput {
  name?: Maybe<String>;
  alias?: Maybe<Json>;
  description?: Maybe<String>;
  dataType?: Maybe<DataTypeUpdateManyWithoutApplicationInput>;
  businessOwner?: Maybe<BusinessRoleUpdateOneWithoutAppBusinessOwnerInput>;
  itOwner?: Maybe<BusinessRoleUpdateOneWithoutAppItOwnerInput>;
  securityAdministrator?: Maybe<BusinessRoleUpdateOneWithoutAppSecAdminInput>;
}

export interface ProcessWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  organizationalUnit?: Maybe<OrganizationalUnitWhereInput>;
  processingActivities_every?: Maybe<ProcessingActivityWhereInput>;
  processingActivities_some?: Maybe<ProcessingActivityWhereInput>;
  processingActivities_none?: Maybe<ProcessingActivityWhereInput>;
  processOwner?: Maybe<BusinessRoleWhereInput>;
  AND?: Maybe<ProcessWhereInput[] | ProcessWhereInput>;
  OR?: Maybe<ProcessWhereInput[] | ProcessWhereInput>;
  NOT?: Maybe<ProcessWhereInput[] | ProcessWhereInput>;
}

export interface DataTypeUpdateManyWithoutApplicationInput {
  create?: Maybe<
    | DataTypeCreateWithoutApplicationInput[]
    | DataTypeCreateWithoutApplicationInput
  >;
  delete?: Maybe<DataTypeWhereUniqueInput[] | DataTypeWhereUniqueInput>;
  connect?: Maybe<DataTypeWhereUniqueInput[] | DataTypeWhereUniqueInput>;
  set?: Maybe<DataTypeWhereUniqueInput[] | DataTypeWhereUniqueInput>;
  disconnect?: Maybe<DataTypeWhereUniqueInput[] | DataTypeWhereUniqueInput>;
  update?: Maybe<
    | DataTypeUpdateWithWhereUniqueWithoutApplicationInput[]
    | DataTypeUpdateWithWhereUniqueWithoutApplicationInput
  >;
  upsert?: Maybe<
    | DataTypeUpsertWithWhereUniqueWithoutApplicationInput[]
    | DataTypeUpsertWithWhereUniqueWithoutApplicationInput
  >;
  deleteMany?: Maybe<DataTypeScalarWhereInput[] | DataTypeScalarWhereInput>;
  updateMany?: Maybe<
    | DataTypeUpdateManyWithWhereNestedInput[]
    | DataTypeUpdateManyWithWhereNestedInput
  >;
}

export interface PersonUpsertWithoutUserInput {
  update: PersonUpdateWithoutUserDataInput;
  create: PersonCreateWithoutUserInput;
}

export interface DataTypeUpdateWithWhereUniqueWithoutApplicationInput {
  where: DataTypeWhereUniqueInput;
  data: DataTypeUpdateWithoutApplicationDataInput;
}

export interface PersonUpdateOneWithoutUserInput {
  create?: Maybe<PersonCreateWithoutUserInput>;
  update?: Maybe<PersonUpdateWithoutUserDataInput>;
  upsert?: Maybe<PersonUpsertWithoutUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PersonWhereUniqueInput>;
}

export interface DataTypeUpdateWithoutApplicationDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  classifications?: Maybe<ClassificationUpdateManyWithoutDataTypeInput>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  active?: Maybe<Boolean>;
  specialPermissions?: Maybe<UserUpdatespecialPermissionsInput>;
  person?: Maybe<PersonUpdateOneWithoutUserInput>;
}

export interface ClassificationUpdateManyWithoutDataTypeInput {
  create?: Maybe<
    | ClassificationCreateWithoutDataTypeInput[]
    | ClassificationCreateWithoutDataTypeInput
  >;
  delete?: Maybe<
    ClassificationWhereUniqueInput[] | ClassificationWhereUniqueInput
  >;
  connect?: Maybe<
    ClassificationWhereUniqueInput[] | ClassificationWhereUniqueInput
  >;
  set?: Maybe<
    ClassificationWhereUniqueInput[] | ClassificationWhereUniqueInput
  >;
  disconnect?: Maybe<
    ClassificationWhereUniqueInput[] | ClassificationWhereUniqueInput
  >;
  update?: Maybe<
    | ClassificationUpdateWithWhereUniqueWithoutDataTypeInput[]
    | ClassificationUpdateWithWhereUniqueWithoutDataTypeInput
  >;
  upsert?: Maybe<
    | ClassificationUpsertWithWhereUniqueWithoutDataTypeInput[]
    | ClassificationUpsertWithWhereUniqueWithoutDataTypeInput
  >;
  deleteMany?: Maybe<
    ClassificationScalarWhereInput[] | ClassificationScalarWhereInput
  >;
}

export interface PersonCreateOneWithoutUserInput {
  create?: Maybe<PersonCreateWithoutUserInput>;
  connect?: Maybe<PersonWhereUniqueInput>;
}

export interface ClassificationUpdateWithWhereUniqueWithoutDataTypeInput {
  where: ClassificationWhereUniqueInput;
  data: ClassificationUpdateWithoutDataTypeDataInput;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  active?: Maybe<Boolean>;
  specialPermissions?: Maybe<UserCreatespecialPermissionsInput>;
  person?: Maybe<PersonCreateOneWithoutUserInput>;
}

export interface ClassificationUpdateWithoutDataTypeDataInput {
  classificationLabel?: Maybe<
    ClassificationLabelUpdateOneWithoutClassificationsInput
  >;
}

export interface ClassificationLabelUpdateManyDataInput {
  score?: Maybe<Int>;
  label?: Maybe<String>;
  criteria?: Maybe<String>;
}

export interface ClassificationLabelUpdateOneWithoutClassificationsInput {
  create?: Maybe<ClassificationLabelCreateWithoutClassificationsInput>;
  update?: Maybe<ClassificationLabelUpdateWithoutClassificationsDataInput>;
  upsert?: Maybe<ClassificationLabelUpsertWithoutClassificationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ClassificationLabelWhereUniqueInput>;
}

export interface ClassificationLabelUpdateManyWithWhereNestedInput {
  where: ClassificationLabelScalarWhereInput;
  data: ClassificationLabelUpdateManyDataInput;
}

export interface ClassificationLabelUpdateWithoutClassificationsDataInput {
  score?: Maybe<Int>;
  label?: Maybe<String>;
  criteria?: Maybe<String>;
  qualityAttribute?: Maybe<
    QualityAttributeUpdateOneWithoutClassificationLabelsInput
  >;
}

export interface ClassificationLabelUpsertWithWhereUniqueWithoutQualityAttributeInput {
  where: ClassificationLabelWhereUniqueInput;
  update: ClassificationLabelUpdateWithoutQualityAttributeDataInput;
  create: ClassificationLabelCreateWithoutQualityAttributeInput;
}

export interface QualityAttributeUpdateOneWithoutClassificationLabelsInput {
  create?: Maybe<QualityAttributeCreateWithoutClassificationLabelsInput>;
  update?: Maybe<QualityAttributeUpdateWithoutClassificationLabelsDataInput>;
  upsert?: Maybe<QualityAttributeUpsertWithoutClassificationLabelsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<QualityAttributeWhereUniqueInput>;
}

export interface ClassificationLabelUpdateWithoutQualityAttributeDataInput {
  score?: Maybe<Int>;
  label?: Maybe<String>;
  criteria?: Maybe<String>;
  classifications?: Maybe<
    ClassificationUpdateManyWithoutClassificationLabelInput
  >;
}

export interface QualityAttributeUpdateWithoutClassificationLabelsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  appliesToObject?: Maybe<CLASSIFICATIONOBJECT>;
}

export interface ClassificationLabelUpdateManyWithoutQualityAttributeInput {
  create?: Maybe<
    | ClassificationLabelCreateWithoutQualityAttributeInput[]
    | ClassificationLabelCreateWithoutQualityAttributeInput
  >;
  delete?: Maybe<
    ClassificationLabelWhereUniqueInput[] | ClassificationLabelWhereUniqueInput
  >;
  connect?: Maybe<
    ClassificationLabelWhereUniqueInput[] | ClassificationLabelWhereUniqueInput
  >;
  set?: Maybe<
    ClassificationLabelWhereUniqueInput[] | ClassificationLabelWhereUniqueInput
  >;
  disconnect?: Maybe<
    ClassificationLabelWhereUniqueInput[] | ClassificationLabelWhereUniqueInput
  >;
  update?: Maybe<
    | ClassificationLabelUpdateWithWhereUniqueWithoutQualityAttributeInput[]
    | ClassificationLabelUpdateWithWhereUniqueWithoutQualityAttributeInput
  >;
  upsert?: Maybe<
    | ClassificationLabelUpsertWithWhereUniqueWithoutQualityAttributeInput[]
    | ClassificationLabelUpsertWithWhereUniqueWithoutQualityAttributeInput
  >;
  deleteMany?: Maybe<
    ClassificationLabelScalarWhereInput[] | ClassificationLabelScalarWhereInput
  >;
  updateMany?: Maybe<
    | ClassificationLabelUpdateManyWithWhereNestedInput[]
    | ClassificationLabelUpdateManyWithWhereNestedInput
  >;
}

export interface QualityAttributeUpsertWithoutClassificationLabelsInput {
  update: QualityAttributeUpdateWithoutClassificationLabelsDataInput;
  create: QualityAttributeCreateWithoutClassificationLabelsInput;
}

export interface QualityAttributeUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  appliesToObject?: Maybe<CLASSIFICATIONOBJECT>;
  classificationLabels?: Maybe<
    ClassificationLabelUpdateManyWithoutQualityAttributeInput
  >;
}

export interface ClassificationLabelUpsertWithoutClassificationsInput {
  update: ClassificationLabelUpdateWithoutClassificationsDataInput;
  create: ClassificationLabelCreateWithoutClassificationsInput;
}

export interface ClassificationLabelCreateManyWithoutQualityAttributeInput {
  create?: Maybe<
    | ClassificationLabelCreateWithoutQualityAttributeInput[]
    | ClassificationLabelCreateWithoutQualityAttributeInput
  >;
  connect?: Maybe<
    ClassificationLabelWhereUniqueInput[] | ClassificationLabelWhereUniqueInput
  >;
}

export interface ClassificationUpsertWithWhereUniqueWithoutDataTypeInput {
  where: ClassificationWhereUniqueInput;
  update: ClassificationUpdateWithoutDataTypeDataInput;
  create: ClassificationCreateWithoutDataTypeInput;
}

export interface QualityAttributeCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  appliesToObject: CLASSIFICATIONOBJECT;
  classificationLabels?: Maybe<
    ClassificationLabelCreateManyWithoutQualityAttributeInput
  >;
}

export interface ClassificationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<
    ClassificationScalarWhereInput[] | ClassificationScalarWhereInput
  >;
  OR?: Maybe<ClassificationScalarWhereInput[] | ClassificationScalarWhereInput>;
  NOT?: Maybe<
    ClassificationScalarWhereInput[] | ClassificationScalarWhereInput
  >;
}

export interface ProcessingActivityUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  purpose?: Maybe<String>;
  process?: Maybe<ProcessUpdateOneWithoutProcessingActivitiesInput>;
  applications?: Maybe<ApplicationUpdateManyWithoutProcessingActivitiesInput>;
}

export interface DataTypeUpsertWithWhereUniqueWithoutApplicationInput {
  where: DataTypeWhereUniqueInput;
  update: DataTypeUpdateWithoutApplicationDataInput;
  create: DataTypeCreateWithoutApplicationInput;
}

export type PersonWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DataTypeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<DataTypeScalarWhereInput[] | DataTypeScalarWhereInput>;
  OR?: Maybe<DataTypeScalarWhereInput[] | DataTypeScalarWhereInput>;
  NOT?: Maybe<DataTypeScalarWhereInput[] | DataTypeScalarWhereInput>;
}

export interface ProcessUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface DataTypeUpdateManyWithWhereNestedInput {
  where: DataTypeScalarWhereInput;
  data: DataTypeUpdateManyDataInput;
}

export interface ProcessCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  organizationalUnit?: Maybe<OrganizationalUnitCreateOneWithoutProcessesInput>;
  processingActivities?: Maybe<ProcessingActivityCreateManyWithoutProcessInput>;
  processOwner?: Maybe<BusinessRoleCreateOneWithoutProcessInput>;
}

export interface DataTypeUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface PersonUpdateManyMutationInput {
  name?: Maybe<String>;
  surname?: Maybe<String>;
}

export interface OrganizationalUnitTypeUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  reportingUnit?: Maybe<Boolean>;
  organizationalUnit?: Maybe<
    OrganizationalUnitUpdateManyWithoutOrganizationalUnitTypeInput
  >;
}

export interface BusinessRoleUpdateWithoutPersonDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
  organizationalUnit?: Maybe<
    OrganizationalUnitUpdateOneRequiredWithoutBusinessRolesInput
  >;
  process?: Maybe<ProcessUpdateManyWithoutProcessOwnerInput>;
  appBusinessOwner?: Maybe<ApplicationUpdateManyWithoutBusinessOwnerInput>;
  appItOwner?: Maybe<ApplicationUpdateManyWithoutItOwnerInput>;
  appSecAdmin?: Maybe<ApplicationUpdateManyWithoutSecurityAdministratorInput>;
}

export interface BusinessRoleUpdateWithoutAppBusinessOwnerDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
  person?: Maybe<PersonUpdateOneWithoutRolesInput>;
  organizationalUnit?: Maybe<
    OrganizationalUnitUpdateOneRequiredWithoutBusinessRolesInput
  >;
  process?: Maybe<ProcessUpdateManyWithoutProcessOwnerInput>;
  appItOwner?: Maybe<ApplicationUpdateManyWithoutItOwnerInput>;
  appSecAdmin?: Maybe<ApplicationUpdateManyWithoutSecurityAdministratorInput>;
}

export interface BusinessRoleUpdateWithWhereUniqueWithoutPersonInput {
  where: BusinessRoleWhereUniqueInput;
  data: BusinessRoleUpdateWithoutPersonDataInput;
}

export interface PersonUpdateOneWithoutRolesInput {
  create?: Maybe<PersonCreateWithoutRolesInput>;
  update?: Maybe<PersonUpdateWithoutRolesDataInput>;
  upsert?: Maybe<PersonUpsertWithoutRolesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PersonWhereUniqueInput>;
}

export interface PersonUpdateInput {
  name?: Maybe<String>;
  surname?: Maybe<String>;
  user?: Maybe<UserUpdateOneWithoutPersonInput>;
  roles?: Maybe<BusinessRoleUpdateManyWithoutPersonInput>;
}

export interface PersonUpdateWithoutRolesDataInput {
  name?: Maybe<String>;
  surname?: Maybe<String>;
  user?: Maybe<UserUpdateOneWithoutPersonInput>;
}

export interface BusinessRoleCreateWithoutPersonInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
  organizationalUnit: OrganizationalUnitCreateOneWithoutBusinessRolesInput;
  process?: Maybe<ProcessCreateManyWithoutProcessOwnerInput>;
  appBusinessOwner?: Maybe<ApplicationCreateManyWithoutBusinessOwnerInput>;
  appItOwner?: Maybe<ApplicationCreateManyWithoutItOwnerInput>;
  appSecAdmin?: Maybe<ApplicationCreateManyWithoutSecurityAdministratorInput>;
}

export interface UserUpdateOneWithoutPersonInput {
  create?: Maybe<UserCreateWithoutPersonInput>;
  update?: Maybe<UserUpdateWithoutPersonDataInput>;
  upsert?: Maybe<UserUpsertWithoutPersonInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface PersonCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  surname?: Maybe<String>;
  user?: Maybe<UserCreateOneWithoutPersonInput>;
  roles?: Maybe<BusinessRoleCreateManyWithoutPersonInput>;
}

export interface UserUpdateWithoutPersonDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  active?: Maybe<Boolean>;
  specialPermissions?: Maybe<UserUpdatespecialPermissionsInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface UserUpdatespecialPermissionsInput {
  set?: Maybe<PERMISSION[] | PERMISSION>;
}

export interface OrganizationalUnitUpdateWithoutOrganizationalUnitTypeDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  children?: Maybe<OrganizationalUnitUpdateManyWithoutParentInput>;
  parent?: Maybe<OrganizationalUnitUpdateOneWithoutChildrenInput>;
  processes?: Maybe<ProcessUpdateManyWithoutOrganizationalUnitInput>;
  businessRoles?: Maybe<BusinessRoleUpdateManyWithoutOrganizationalUnitInput>;
}

export interface UserUpsertWithoutPersonInput {
  update: UserUpdateWithoutPersonDataInput;
  create: UserCreateWithoutPersonInput;
}

export interface OrganizationalUnitUpdateManyWithoutOrganizationalUnitTypeInput {
  create?: Maybe<
    | OrganizationalUnitCreateWithoutOrganizationalUnitTypeInput[]
    | OrganizationalUnitCreateWithoutOrganizationalUnitTypeInput
  >;
  delete?: Maybe<
    OrganizationalUnitWhereUniqueInput[] | OrganizationalUnitWhereUniqueInput
  >;
  connect?: Maybe<
    OrganizationalUnitWhereUniqueInput[] | OrganizationalUnitWhereUniqueInput
  >;
  set?: Maybe<
    OrganizationalUnitWhereUniqueInput[] | OrganizationalUnitWhereUniqueInput
  >;
  disconnect?: Maybe<
    OrganizationalUnitWhereUniqueInput[] | OrganizationalUnitWhereUniqueInput
  >;
  update?: Maybe<
    | OrganizationalUnitUpdateWithWhereUniqueWithoutOrganizationalUnitTypeInput[]
    | OrganizationalUnitUpdateWithWhereUniqueWithoutOrganizationalUnitTypeInput
  >;
  upsert?: Maybe<
    | OrganizationalUnitUpsertWithWhereUniqueWithoutOrganizationalUnitTypeInput[]
    | OrganizationalUnitUpsertWithWhereUniqueWithoutOrganizationalUnitTypeInput
  >;
  deleteMany?: Maybe<
    OrganizationalUnitScalarWhereInput[] | OrganizationalUnitScalarWhereInput
  >;
  updateMany?: Maybe<
    | OrganizationalUnitUpdateManyWithWhereNestedInput[]
    | OrganizationalUnitUpdateManyWithWhereNestedInput
  >;
}

export interface PersonUpsertWithoutRolesInput {
  update: PersonUpdateWithoutRolesDataInput;
  create: PersonCreateWithoutRolesInput;
}

export interface ApplicationCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  alias?: Maybe<Json>;
  description?: Maybe<String>;
  processingActivities?: Maybe<
    ProcessingActivityCreateManyWithoutApplicationsInput
  >;
  dataType?: Maybe<DataTypeCreateManyWithoutApplicationInput>;
  businessOwner?: Maybe<BusinessRoleCreateOneWithoutAppBusinessOwnerInput>;
  itOwner?: Maybe<BusinessRoleCreateOneWithoutAppItOwnerInput>;
  securityAdministrator?: Maybe<BusinessRoleCreateOneWithoutAppSecAdminInput>;
}

export interface QualityAttributeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  appliesToObject?: Maybe<CLASSIFICATIONOBJECT>;
  appliesToObject_not?: Maybe<CLASSIFICATIONOBJECT>;
  appliesToObject_in?: Maybe<CLASSIFICATIONOBJECT[] | CLASSIFICATIONOBJECT>;
  appliesToObject_not_in?: Maybe<CLASSIFICATIONOBJECT[] | CLASSIFICATIONOBJECT>;
  classificationLabels_every?: Maybe<ClassificationLabelWhereInput>;
  classificationLabels_some?: Maybe<ClassificationLabelWhereInput>;
  classificationLabels_none?: Maybe<ClassificationLabelWhereInput>;
  AND?: Maybe<QualityAttributeWhereInput[] | QualityAttributeWhereInput>;
  OR?: Maybe<QualityAttributeWhereInput[] | QualityAttributeWhereInput>;
  NOT?: Maybe<QualityAttributeWhereInput[] | QualityAttributeWhereInput>;
}

export interface ProcessingActivityCreateWithoutApplicationsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  purpose?: Maybe<String>;
  process?: Maybe<ProcessCreateOneWithoutProcessingActivitiesInput>;
}

export interface OrganizationalUnitUpdateWithoutBusinessRolesDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  children?: Maybe<OrganizationalUnitUpdateManyWithoutParentInput>;
  parent?: Maybe<OrganizationalUnitUpdateOneWithoutChildrenInput>;
  processes?: Maybe<ProcessUpdateManyWithoutOrganizationalUnitInput>;
  organizationalUnitType?: Maybe<
    OrganizationalUnitTypeUpdateOneWithoutOrganizationalUnitInput
  >;
}

export interface ProcessCreateWithoutProcessingActivitiesInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  organizationalUnit?: Maybe<OrganizationalUnitCreateOneWithoutProcessesInput>;
  processOwner?: Maybe<BusinessRoleCreateOneWithoutProcessInput>;
}

export interface OrganizationalUnitUpdateOneWithoutChildrenInput {
  create?: Maybe<OrganizationalUnitCreateWithoutChildrenInput>;
  update?: Maybe<OrganizationalUnitUpdateWithoutChildrenDataInput>;
  upsert?: Maybe<OrganizationalUnitUpsertWithoutChildrenInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<OrganizationalUnitWhereUniqueInput>;
}

export interface OrganizationalUnitCreateWithoutProcessesInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  children?: Maybe<OrganizationalUnitCreateManyWithoutParentInput>;
  parent?: Maybe<OrganizationalUnitCreateOneWithoutChildrenInput>;
  businessRoles?: Maybe<BusinessRoleCreateManyWithoutOrganizationalUnitInput>;
  organizationalUnitType?: Maybe<
    OrganizationalUnitTypeCreateOneWithoutOrganizationalUnitInput
  >;
}

export interface OrganizationalUnitUpdateWithoutChildrenDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  parent?: Maybe<OrganizationalUnitUpdateOneWithoutChildrenInput>;
  processes?: Maybe<ProcessUpdateManyWithoutOrganizationalUnitInput>;
  businessRoles?: Maybe<BusinessRoleUpdateManyWithoutOrganizationalUnitInput>;
  organizationalUnitType?: Maybe<
    OrganizationalUnitTypeUpdateOneWithoutOrganizationalUnitInput
  >;
}

export interface OrganizationalUnitCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  children?: Maybe<OrganizationalUnitCreateManyWithoutParentInput>;
  processes?: Maybe<ProcessCreateManyWithoutOrganizationalUnitInput>;
  businessRoles?: Maybe<BusinessRoleCreateManyWithoutOrganizationalUnitInput>;
  organizationalUnitType?: Maybe<
    OrganizationalUnitTypeCreateOneWithoutOrganizationalUnitInput
  >;
}

export interface BusinessRoleUpdateManyWithoutOrganizationalUnitInput {
  create?: Maybe<
    | BusinessRoleCreateWithoutOrganizationalUnitInput[]
    | BusinessRoleCreateWithoutOrganizationalUnitInput
  >;
  delete?: Maybe<BusinessRoleWhereUniqueInput[] | BusinessRoleWhereUniqueInput>;
  connect?: Maybe<
    BusinessRoleWhereUniqueInput[] | BusinessRoleWhereUniqueInput
  >;
  set?: Maybe<BusinessRoleWhereUniqueInput[] | BusinessRoleWhereUniqueInput>;
  disconnect?: Maybe<
    BusinessRoleWhereUniqueInput[] | BusinessRoleWhereUniqueInput
  >;
  update?: Maybe<
    | BusinessRoleUpdateWithWhereUniqueWithoutOrganizationalUnitInput[]
    | BusinessRoleUpdateWithWhereUniqueWithoutOrganizationalUnitInput
  >;
  upsert?: Maybe<
    | BusinessRoleUpsertWithWhereUniqueWithoutOrganizationalUnitInput[]
    | BusinessRoleUpsertWithWhereUniqueWithoutOrganizationalUnitInput
  >;
  deleteMany?: Maybe<
    BusinessRoleScalarWhereInput[] | BusinessRoleScalarWhereInput
  >;
  updateMany?: Maybe<
    | BusinessRoleUpdateManyWithWhereNestedInput[]
    | BusinessRoleUpdateManyWithWhereNestedInput
  >;
}

export interface ProcessCreateWithoutOrganizationalUnitInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  processingActivities?: Maybe<ProcessingActivityCreateManyWithoutProcessInput>;
  processOwner?: Maybe<BusinessRoleCreateOneWithoutProcessInput>;
}

export interface BusinessRoleUpdateWithWhereUniqueWithoutOrganizationalUnitInput {
  where: BusinessRoleWhereUniqueInput;
  data: BusinessRoleUpdateWithoutOrganizationalUnitDataInput;
}

export interface ProcessingActivityCreateWithoutProcessInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  purpose?: Maybe<String>;
  applications?: Maybe<ApplicationCreateManyWithoutProcessingActivitiesInput>;
}

export interface BusinessRoleUpdateWithoutOrganizationalUnitDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
  person?: Maybe<PersonUpdateOneWithoutRolesInput>;
  process?: Maybe<ProcessUpdateManyWithoutProcessOwnerInput>;
  appBusinessOwner?: Maybe<ApplicationUpdateManyWithoutBusinessOwnerInput>;
  appItOwner?: Maybe<ApplicationUpdateManyWithoutItOwnerInput>;
  appSecAdmin?: Maybe<ApplicationUpdateManyWithoutSecurityAdministratorInput>;
}

export interface ApplicationCreateWithoutProcessingActivitiesInput {
  id?: Maybe<ID_Input>;
  name: String;
  alias?: Maybe<Json>;
  description?: Maybe<String>;
  dataType?: Maybe<DataTypeCreateManyWithoutApplicationInput>;
  businessOwner?: Maybe<BusinessRoleCreateOneWithoutAppBusinessOwnerInput>;
  itOwner?: Maybe<BusinessRoleCreateOneWithoutAppItOwnerInput>;
  securityAdministrator?: Maybe<BusinessRoleCreateOneWithoutAppSecAdminInput>;
}

export interface ProcessUpdateManyWithoutProcessOwnerInput {
  create?: Maybe<
    | ProcessCreateWithoutProcessOwnerInput[]
    | ProcessCreateWithoutProcessOwnerInput
  >;
  delete?: Maybe<ProcessWhereUniqueInput[] | ProcessWhereUniqueInput>;
  connect?: Maybe<ProcessWhereUniqueInput[] | ProcessWhereUniqueInput>;
  set?: Maybe<ProcessWhereUniqueInput[] | ProcessWhereUniqueInput>;
  disconnect?: Maybe<ProcessWhereUniqueInput[] | ProcessWhereUniqueInput>;
  update?: Maybe<
    | ProcessUpdateWithWhereUniqueWithoutProcessOwnerInput[]
    | ProcessUpdateWithWhereUniqueWithoutProcessOwnerInput
  >;
  upsert?: Maybe<
    | ProcessUpsertWithWhereUniqueWithoutProcessOwnerInput[]
    | ProcessUpsertWithWhereUniqueWithoutProcessOwnerInput
  >;
  deleteMany?: Maybe<ProcessScalarWhereInput[] | ProcessScalarWhereInput>;
  updateMany?: Maybe<
    | ProcessUpdateManyWithWhereNestedInput[]
    | ProcessUpdateManyWithWhereNestedInput
  >;
}

export interface DataTypeCreateWithoutApplicationInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  classifications?: Maybe<ClassificationCreateManyWithoutDataTypeInput>;
}

export interface ProcessUpdateWithWhereUniqueWithoutProcessOwnerInput {
  where: ProcessWhereUniqueInput;
  data: ProcessUpdateWithoutProcessOwnerDataInput;
}

export interface ClassificationCreateWithoutDataTypeInput {
  id?: Maybe<ID_Input>;
  classificationLabel?: Maybe<
    ClassificationLabelCreateOneWithoutClassificationsInput
  >;
}

export interface ProcessUpdateWithoutProcessOwnerDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  organizationalUnit?: Maybe<OrganizationalUnitUpdateOneWithoutProcessesInput>;
  processingActivities?: Maybe<ProcessingActivityUpdateManyWithoutProcessInput>;
}

export interface ClassificationLabelCreateWithoutClassificationsInput {
  id?: Maybe<ID_Input>;
  score: Int;
  label: String;
  criteria?: Maybe<String>;
  qualityAttribute?: Maybe<
    QualityAttributeCreateOneWithoutClassificationLabelsInput
  >;
}

export interface ProcessUpsertWithWhereUniqueWithoutProcessOwnerInput {
  where: ProcessWhereUniqueInput;
  update: ProcessUpdateWithoutProcessOwnerDataInput;
  create: ProcessCreateWithoutProcessOwnerInput;
}

export interface QualityAttributeCreateWithoutClassificationLabelsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  appliesToObject: CLASSIFICATIONOBJECT;
}

export interface ProcessScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProcessScalarWhereInput[] | ProcessScalarWhereInput>;
  OR?: Maybe<ProcessScalarWhereInput[] | ProcessScalarWhereInput>;
  NOT?: Maybe<ProcessScalarWhereInput[] | ProcessScalarWhereInput>;
}

export interface BusinessRoleCreateWithoutAppBusinessOwnerInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
  person?: Maybe<PersonCreateOneWithoutRolesInput>;
  organizationalUnit: OrganizationalUnitCreateOneWithoutBusinessRolesInput;
  process?: Maybe<ProcessCreateManyWithoutProcessOwnerInput>;
  appItOwner?: Maybe<ApplicationCreateManyWithoutItOwnerInput>;
  appSecAdmin?: Maybe<ApplicationCreateManyWithoutSecurityAdministratorInput>;
}

export interface ProcessUpdateManyWithWhereNestedInput {
  where: ProcessScalarWhereInput;
  data: ProcessUpdateManyDataInput;
}

export interface PersonCreateWithoutRolesInput {
  id?: Maybe<ID_Input>;
  name: String;
  surname?: Maybe<String>;
  user?: Maybe<UserCreateOneWithoutPersonInput>;
}

export interface ProcessUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface UserCreateWithoutPersonInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  active?: Maybe<Boolean>;
  specialPermissions?: Maybe<UserCreatespecialPermissionsInput>;
}

export interface ApplicationUpdateManyWithoutBusinessOwnerInput {
  create?: Maybe<
    | ApplicationCreateWithoutBusinessOwnerInput[]
    | ApplicationCreateWithoutBusinessOwnerInput
  >;
  delete?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  set?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  disconnect?: Maybe<
    ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput
  >;
  update?: Maybe<
    | ApplicationUpdateWithWhereUniqueWithoutBusinessOwnerInput[]
    | ApplicationUpdateWithWhereUniqueWithoutBusinessOwnerInput
  >;
  upsert?: Maybe<
    | ApplicationUpsertWithWhereUniqueWithoutBusinessOwnerInput[]
    | ApplicationUpsertWithWhereUniqueWithoutBusinessOwnerInput
  >;
  deleteMany?: Maybe<
    ApplicationScalarWhereInput[] | ApplicationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput
  >;
}

export interface OrganizationalUnitCreateOneWithoutBusinessRolesInput {
  create?: Maybe<OrganizationalUnitCreateWithoutBusinessRolesInput>;
  connect?: Maybe<OrganizationalUnitWhereUniqueInput>;
}

export interface ApplicationUpdateWithWhereUniqueWithoutBusinessOwnerInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutBusinessOwnerDataInput;
}

export interface OrganizationalUnitCreateOneWithoutChildrenInput {
  create?: Maybe<OrganizationalUnitCreateWithoutChildrenInput>;
  connect?: Maybe<OrganizationalUnitWhereUniqueInput>;
}

export interface ApplicationUpdateWithoutBusinessOwnerDataInput {
  name?: Maybe<String>;
  alias?: Maybe<Json>;
  description?: Maybe<String>;
  processingActivities?: Maybe<
    ProcessingActivityUpdateManyWithoutApplicationsInput
  >;
  dataType?: Maybe<DataTypeUpdateManyWithoutApplicationInput>;
  itOwner?: Maybe<BusinessRoleUpdateOneWithoutAppItOwnerInput>;
  securityAdministrator?: Maybe<BusinessRoleUpdateOneWithoutAppSecAdminInput>;
}

export interface BusinessRoleCreateManyWithoutOrganizationalUnitInput {
  create?: Maybe<
    | BusinessRoleCreateWithoutOrganizationalUnitInput[]
    | BusinessRoleCreateWithoutOrganizationalUnitInput
  >;
  connect?: Maybe<
    BusinessRoleWhereUniqueInput[] | BusinessRoleWhereUniqueInput
  >;
}

export interface BusinessRoleUpdateOneWithoutAppItOwnerInput {
  create?: Maybe<BusinessRoleCreateWithoutAppItOwnerInput>;
  update?: Maybe<BusinessRoleUpdateWithoutAppItOwnerDataInput>;
  upsert?: Maybe<BusinessRoleUpsertWithoutAppItOwnerInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BusinessRoleWhereUniqueInput>;
}

export interface ProcessCreateManyWithoutProcessOwnerInput {
  create?: Maybe<
    | ProcessCreateWithoutProcessOwnerInput[]
    | ProcessCreateWithoutProcessOwnerInput
  >;
  connect?: Maybe<ProcessWhereUniqueInput[] | ProcessWhereUniqueInput>;
}

export interface BusinessRoleUpdateWithoutAppItOwnerDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
  person?: Maybe<PersonUpdateOneWithoutRolesInput>;
  organizationalUnit?: Maybe<
    OrganizationalUnitUpdateOneRequiredWithoutBusinessRolesInput
  >;
  process?: Maybe<ProcessUpdateManyWithoutProcessOwnerInput>;
  appBusinessOwner?: Maybe<ApplicationUpdateManyWithoutBusinessOwnerInput>;
  appSecAdmin?: Maybe<ApplicationUpdateManyWithoutSecurityAdministratorInput>;
}

export interface ApplicationCreateManyWithoutBusinessOwnerInput {
  create?: Maybe<
    | ApplicationCreateWithoutBusinessOwnerInput[]
    | ApplicationCreateWithoutBusinessOwnerInput
  >;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
}

export interface ApplicationUpdateManyWithoutSecurityAdministratorInput {
  create?: Maybe<
    | ApplicationCreateWithoutSecurityAdministratorInput[]
    | ApplicationCreateWithoutSecurityAdministratorInput
  >;
  delete?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  set?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  disconnect?: Maybe<
    ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput
  >;
  update?: Maybe<
    | ApplicationUpdateWithWhereUniqueWithoutSecurityAdministratorInput[]
    | ApplicationUpdateWithWhereUniqueWithoutSecurityAdministratorInput
  >;
  upsert?: Maybe<
    | ApplicationUpsertWithWhereUniqueWithoutSecurityAdministratorInput[]
    | ApplicationUpsertWithWhereUniqueWithoutSecurityAdministratorInput
  >;
  deleteMany?: Maybe<
    ApplicationScalarWhereInput[] | ApplicationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput
  >;
}

export interface BusinessRoleCreateOneWithoutAppItOwnerInput {
  create?: Maybe<BusinessRoleCreateWithoutAppItOwnerInput>;
  connect?: Maybe<BusinessRoleWhereUniqueInput>;
}

export interface ApplicationUpdateWithWhereUniqueWithoutSecurityAdministratorInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutSecurityAdministratorDataInput;
}

export interface ApplicationCreateManyWithoutSecurityAdministratorInput {
  create?: Maybe<
    | ApplicationCreateWithoutSecurityAdministratorInput[]
    | ApplicationCreateWithoutSecurityAdministratorInput
  >;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
}

export interface ApplicationUpdateWithoutSecurityAdministratorDataInput {
  name?: Maybe<String>;
  alias?: Maybe<Json>;
  description?: Maybe<String>;
  processingActivities?: Maybe<
    ProcessingActivityUpdateManyWithoutApplicationsInput
  >;
  dataType?: Maybe<DataTypeUpdateManyWithoutApplicationInput>;
  businessOwner?: Maybe<BusinessRoleUpdateOneWithoutAppBusinessOwnerInput>;
  itOwner?: Maybe<BusinessRoleUpdateOneWithoutAppItOwnerInput>;
}

export interface BusinessRoleCreateOneWithoutAppSecAdminInput {
  create?: Maybe<BusinessRoleCreateWithoutAppSecAdminInput>;
  connect?: Maybe<BusinessRoleWhereUniqueInput>;
}

export interface ApplicationUpsertWithWhereUniqueWithoutSecurityAdministratorInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutSecurityAdministratorDataInput;
  create: ApplicationCreateWithoutSecurityAdministratorInput;
}

export interface ApplicationCreateManyWithoutItOwnerInput {
  create?: Maybe<
    | ApplicationCreateWithoutItOwnerInput[]
    | ApplicationCreateWithoutItOwnerInput
  >;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
}

export interface ApplicationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
  OR?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
  NOT?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
}

export interface OrganizationalUnitTypeCreateOneWithoutOrganizationalUnitInput {
  create?: Maybe<OrganizationalUnitTypeCreateWithoutOrganizationalUnitInput>;
  connect?: Maybe<OrganizationalUnitTypeWhereUniqueInput>;
}

export interface ApplicationUpdateManyWithWhereNestedInput {
  where: ApplicationScalarWhereInput;
  data: ApplicationUpdateManyDataInput;
}

export interface BusinessRoleCreateOneWithoutProcessInput {
  create?: Maybe<BusinessRoleCreateWithoutProcessInput>;
  connect?: Maybe<BusinessRoleWhereUniqueInput>;
}

export interface ApplicationUpdateManyDataInput {
  name?: Maybe<String>;
  alias?: Maybe<Json>;
  description?: Maybe<String>;
}

export interface ApplicationUpdateInput {
  name?: Maybe<String>;
  alias?: Maybe<Json>;
  description?: Maybe<String>;
  processingActivities?: Maybe<
    ProcessingActivityUpdateManyWithoutApplicationsInput
  >;
  dataType?: Maybe<DataTypeUpdateManyWithoutApplicationInput>;
  businessOwner?: Maybe<BusinessRoleUpdateOneWithoutAppBusinessOwnerInput>;
  itOwner?: Maybe<BusinessRoleUpdateOneWithoutAppItOwnerInput>;
  securityAdministrator?: Maybe<BusinessRoleUpdateOneWithoutAppSecAdminInput>;
}

export interface BusinessRoleUpsertWithoutAppItOwnerInput {
  update: BusinessRoleUpdateWithoutAppItOwnerDataInput;
  create: BusinessRoleCreateWithoutAppItOwnerInput;
}

export interface ProcessingActivityUpdateWithWhereUniqueWithoutApplicationsInput {
  where: ProcessingActivityWhereUniqueInput;
  data: ProcessingActivityUpdateWithoutApplicationsDataInput;
}

export interface BusinessRoleUpdateOneWithoutAppSecAdminInput {
  create?: Maybe<BusinessRoleCreateWithoutAppSecAdminInput>;
  update?: Maybe<BusinessRoleUpdateWithoutAppSecAdminDataInput>;
  upsert?: Maybe<BusinessRoleUpsertWithoutAppSecAdminInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BusinessRoleWhereUniqueInput>;
}

export interface ProcessUpdateOneWithoutProcessingActivitiesInput {
  create?: Maybe<ProcessCreateWithoutProcessingActivitiesInput>;
  update?: Maybe<ProcessUpdateWithoutProcessingActivitiesDataInput>;
  upsert?: Maybe<ProcessUpsertWithoutProcessingActivitiesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProcessWhereUniqueInput>;
}

export interface BusinessRoleUpdateWithoutAppSecAdminDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
  person?: Maybe<PersonUpdateOneWithoutRolesInput>;
  organizationalUnit?: Maybe<
    OrganizationalUnitUpdateOneRequiredWithoutBusinessRolesInput
  >;
  process?: Maybe<ProcessUpdateManyWithoutProcessOwnerInput>;
  appBusinessOwner?: Maybe<ApplicationUpdateManyWithoutBusinessOwnerInput>;
  appItOwner?: Maybe<ApplicationUpdateManyWithoutItOwnerInput>;
}

export interface OrganizationalUnitUpdateOneWithoutProcessesInput {
  create?: Maybe<OrganizationalUnitCreateWithoutProcessesInput>;
  update?: Maybe<OrganizationalUnitUpdateWithoutProcessesDataInput>;
  upsert?: Maybe<OrganizationalUnitUpsertWithoutProcessesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<OrganizationalUnitWhereUniqueInput>;
}

export interface ApplicationUpdateManyWithoutItOwnerInput {
  create?: Maybe<
    | ApplicationCreateWithoutItOwnerInput[]
    | ApplicationCreateWithoutItOwnerInput
  >;
  delete?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  set?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  disconnect?: Maybe<
    ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput
  >;
  update?: Maybe<
    | ApplicationUpdateWithWhereUniqueWithoutItOwnerInput[]
    | ApplicationUpdateWithWhereUniqueWithoutItOwnerInput
  >;
  upsert?: Maybe<
    | ApplicationUpsertWithWhereUniqueWithoutItOwnerInput[]
    | ApplicationUpsertWithWhereUniqueWithoutItOwnerInput
  >;
  deleteMany?: Maybe<
    ApplicationScalarWhereInput[] | ApplicationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput
  >;
}

export interface ClassificationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  dataType?: Maybe<DataTypeWhereInput>;
  classificationLabel?: Maybe<ClassificationLabelWhereInput>;
  AND?: Maybe<ClassificationWhereInput[] | ClassificationWhereInput>;
  OR?: Maybe<ClassificationWhereInput[] | ClassificationWhereInput>;
  NOT?: Maybe<ClassificationWhereInput[] | ClassificationWhereInput>;
}

export interface ApplicationUpdateWithWhereUniqueWithoutItOwnerInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutItOwnerDataInput;
}

export interface DataTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  application_every?: Maybe<ApplicationWhereInput>;
  application_some?: Maybe<ApplicationWhereInput>;
  application_none?: Maybe<ApplicationWhereInput>;
  classifications_every?: Maybe<ClassificationWhereInput>;
  classifications_some?: Maybe<ClassificationWhereInput>;
  classifications_none?: Maybe<ClassificationWhereInput>;
  AND?: Maybe<DataTypeWhereInput[] | DataTypeWhereInput>;
  OR?: Maybe<DataTypeWhereInput[] | DataTypeWhereInput>;
  NOT?: Maybe<DataTypeWhereInput[] | DataTypeWhereInput>;
}

export interface ApplicationUpdateWithoutItOwnerDataInput {
  name?: Maybe<String>;
  alias?: Maybe<Json>;
  description?: Maybe<String>;
  processingActivities?: Maybe<
    ProcessingActivityUpdateManyWithoutApplicationsInput
  >;
  dataType?: Maybe<DataTypeUpdateManyWithoutApplicationInput>;
  businessOwner?: Maybe<BusinessRoleUpdateOneWithoutAppBusinessOwnerInput>;
  securityAdministrator?: Maybe<BusinessRoleUpdateOneWithoutAppSecAdminInput>;
}

export interface OrganizationalUnitTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrganizationalUnitTypeWhereInput>;
  AND?: Maybe<
    | OrganizationalUnitTypeSubscriptionWhereInput[]
    | OrganizationalUnitTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    | OrganizationalUnitTypeSubscriptionWhereInput[]
    | OrganizationalUnitTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | OrganizationalUnitTypeSubscriptionWhereInput[]
    | OrganizationalUnitTypeSubscriptionWhereInput
  >;
}

export interface ApplicationUpsertWithWhereUniqueWithoutItOwnerInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutItOwnerDataInput;
  create: ApplicationCreateWithoutItOwnerInput;
}

export interface DataTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DataTypeWhereInput>;
  AND?: Maybe<
    DataTypeSubscriptionWhereInput[] | DataTypeSubscriptionWhereInput
  >;
  OR?: Maybe<DataTypeSubscriptionWhereInput[] | DataTypeSubscriptionWhereInput>;
  NOT?: Maybe<
    DataTypeSubscriptionWhereInput[] | DataTypeSubscriptionWhereInput
  >;
}

export interface BusinessRoleUpsertWithoutAppSecAdminInput {
  update: BusinessRoleUpdateWithoutAppSecAdminDataInput;
  create: BusinessRoleCreateWithoutAppSecAdminInput;
}

export interface ClassificationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClassificationWhereInput>;
  AND?: Maybe<
    | ClassificationSubscriptionWhereInput[]
    | ClassificationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ClassificationSubscriptionWhereInput[]
    | ClassificationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ClassificationSubscriptionWhereInput[]
    | ClassificationSubscriptionWhereInput
  >;
}

export interface ApplicationUpsertWithWhereUniqueWithoutBusinessOwnerInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutBusinessOwnerDataInput;
  create: ApplicationCreateWithoutBusinessOwnerInput;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  active?: Maybe<Boolean>;
  specialPermissions?: Maybe<UserUpdatespecialPermissionsInput>;
}

export interface BusinessRoleUpsertWithWhereUniqueWithoutOrganizationalUnitInput {
  where: BusinessRoleWhereUniqueInput;
  update: BusinessRoleUpdateWithoutOrganizationalUnitDataInput;
  create: BusinessRoleCreateWithoutOrganizationalUnitInput;
}

export type BusinessRoleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BusinessRoleScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciPrivacy_not?: Maybe<RACI>;
  raciPrivacy_in?: Maybe<RACI[] | RACI>;
  raciPrivacy_not_in?: Maybe<RACI[] | RACI>;
  raciSecurity?: Maybe<RACI>;
  raciSecurity_not?: Maybe<RACI>;
  raciSecurity_in?: Maybe<RACI[] | RACI>;
  raciSecurity_not_in?: Maybe<RACI[] | RACI>;
  raciFinancial?: Maybe<RACI>;
  raciFinancial_not?: Maybe<RACI>;
  raciFinancial_in?: Maybe<RACI[] | RACI>;
  raciFinancial_not_in?: Maybe<RACI[] | RACI>;
  raciExecutive?: Maybe<RACI>;
  raciExecutive_not?: Maybe<RACI>;
  raciExecutive_in?: Maybe<RACI[] | RACI>;
  raciExecutive_not_in?: Maybe<RACI[] | RACI>;
  AND?: Maybe<BusinessRoleScalarWhereInput[] | BusinessRoleScalarWhereInput>;
  OR?: Maybe<BusinessRoleScalarWhereInput[] | BusinessRoleScalarWhereInput>;
  NOT?: Maybe<BusinessRoleScalarWhereInput[] | BusinessRoleScalarWhereInput>;
}

export type ClassificationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BusinessRoleUpdateManyWithWhereNestedInput {
  where: BusinessRoleScalarWhereInput;
  data: BusinessRoleUpdateManyDataInput;
}

export type ClassificationLabelWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BusinessRoleUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
}

export type DataTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OrganizationalUnitTypeUpdateOneWithoutOrganizationalUnitInput {
  create?: Maybe<OrganizationalUnitTypeCreateWithoutOrganizationalUnitInput>;
  update?: Maybe<
    OrganizationalUnitTypeUpdateWithoutOrganizationalUnitDataInput
  >;
  upsert?: Maybe<OrganizationalUnitTypeUpsertWithoutOrganizationalUnitInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<OrganizationalUnitTypeWhereUniqueInput>;
}

export type OrganizationalUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OrganizationalUnitTypeUpdateWithoutOrganizationalUnitDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  reportingUnit?: Maybe<Boolean>;
}

export type OrganizationalUnitTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OrganizationalUnitTypeUpsertWithoutOrganizationalUnitInput {
  update: OrganizationalUnitTypeUpdateWithoutOrganizationalUnitDataInput;
  create: OrganizationalUnitTypeCreateWithoutOrganizationalUnitInput;
}

export interface ProcessingActivityCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  purpose?: Maybe<String>;
  process?: Maybe<ProcessCreateOneWithoutProcessingActivitiesInput>;
  applications?: Maybe<ApplicationCreateManyWithoutProcessingActivitiesInput>;
}

export interface OrganizationalUnitUpsertWithoutChildrenInput {
  update: OrganizationalUnitUpdateWithoutChildrenDataInput;
  create: OrganizationalUnitCreateWithoutChildrenInput;
}

export interface ProcessUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  organizationalUnit?: Maybe<OrganizationalUnitUpdateOneWithoutProcessesInput>;
  processingActivities?: Maybe<ProcessingActivityUpdateManyWithoutProcessInput>;
  processOwner?: Maybe<BusinessRoleUpdateOneWithoutProcessInput>;
}

export interface OrganizationalUnitUpsertWithoutBusinessRolesInput {
  update: OrganizationalUnitUpdateWithoutBusinessRolesDataInput;
  create: OrganizationalUnitCreateWithoutBusinessRolesInput;
}

export interface BusinessRoleUpsertWithWhereUniqueWithoutPersonInput {
  where: BusinessRoleWhereUniqueInput;
  update: BusinessRoleUpdateWithoutPersonDataInput;
  create: BusinessRoleCreateWithoutPersonInput;
}

export interface BusinessRoleUpsertWithoutAppBusinessOwnerInput {
  update: BusinessRoleUpdateWithoutAppBusinessOwnerDataInput;
  create: BusinessRoleCreateWithoutAppBusinessOwnerInput;
}

export interface BusinessRoleUpdateManyWithoutPersonInput {
  create?: Maybe<
    | BusinessRoleCreateWithoutPersonInput[]
    | BusinessRoleCreateWithoutPersonInput
  >;
  delete?: Maybe<BusinessRoleWhereUniqueInput[] | BusinessRoleWhereUniqueInput>;
  connect?: Maybe<
    BusinessRoleWhereUniqueInput[] | BusinessRoleWhereUniqueInput
  >;
  set?: Maybe<BusinessRoleWhereUniqueInput[] | BusinessRoleWhereUniqueInput>;
  disconnect?: Maybe<
    BusinessRoleWhereUniqueInput[] | BusinessRoleWhereUniqueInput
  >;
  update?: Maybe<
    | BusinessRoleUpdateWithWhereUniqueWithoutPersonInput[]
    | BusinessRoleUpdateWithWhereUniqueWithoutPersonInput
  >;
  upsert?: Maybe<
    | BusinessRoleUpsertWithWhereUniqueWithoutPersonInput[]
    | BusinessRoleUpsertWithWhereUniqueWithoutPersonInput
  >;
  deleteMany?: Maybe<
    BusinessRoleScalarWhereInput[] | BusinessRoleScalarWhereInput
  >;
  updateMany?: Maybe<
    | BusinessRoleUpdateManyWithWhereNestedInput[]
    | BusinessRoleUpdateManyWithWhereNestedInput
  >;
}

export interface ApplicationUpsertWithWhereUniqueWithoutProcessingActivitiesInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutProcessingActivitiesDataInput;
  create: ApplicationCreateWithoutProcessingActivitiesInput;
}

export interface BusinessRoleCreateManyWithoutPersonInput {
  create?: Maybe<
    | BusinessRoleCreateWithoutPersonInput[]
    | BusinessRoleCreateWithoutPersonInput
  >;
  connect?: Maybe<
    BusinessRoleWhereUniqueInput[] | BusinessRoleWhereUniqueInput
  >;
}

export interface ProcessingActivityUpsertWithWhereUniqueWithoutProcessInput {
  where: ProcessingActivityWhereUniqueInput;
  update: ProcessingActivityUpdateWithoutProcessDataInput;
  create: ProcessingActivityCreateWithoutProcessInput;
}

export interface OrganizationalUnitUpsertWithWhereUniqueWithoutOrganizationalUnitTypeInput {
  where: OrganizationalUnitWhereUniqueInput;
  update: OrganizationalUnitUpdateWithoutOrganizationalUnitTypeDataInput;
  create: OrganizationalUnitCreateWithoutOrganizationalUnitTypeInput;
}

export interface ProcessingActivityScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  purpose?: Maybe<String>;
  purpose_not?: Maybe<String>;
  purpose_in?: Maybe<String[] | String>;
  purpose_not_in?: Maybe<String[] | String>;
  purpose_lt?: Maybe<String>;
  purpose_lte?: Maybe<String>;
  purpose_gt?: Maybe<String>;
  purpose_gte?: Maybe<String>;
  purpose_contains?: Maybe<String>;
  purpose_not_contains?: Maybe<String>;
  purpose_starts_with?: Maybe<String>;
  purpose_not_starts_with?: Maybe<String>;
  purpose_ends_with?: Maybe<String>;
  purpose_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ProcessingActivityScalarWhereInput[] | ProcessingActivityScalarWhereInput
  >;
  OR?: Maybe<
    ProcessingActivityScalarWhereInput[] | ProcessingActivityScalarWhereInput
  >;
  NOT?: Maybe<
    ProcessingActivityScalarWhereInput[] | ProcessingActivityScalarWhereInput
  >;
}

export interface ProcessCreateOneWithoutProcessingActivitiesInput {
  create?: Maybe<ProcessCreateWithoutProcessingActivitiesInput>;
  connect?: Maybe<ProcessWhereUniqueInput>;
}

export interface ProcessingActivityUpdateManyWithWhereNestedInput {
  where: ProcessingActivityScalarWhereInput;
  data: ProcessingActivityUpdateManyDataInput;
}

export interface OrganizationalUnitCreateManyWithoutParentInput {
  create?: Maybe<
    | OrganizationalUnitCreateWithoutParentInput[]
    | OrganizationalUnitCreateWithoutParentInput
  >;
  connect?: Maybe<
    OrganizationalUnitWhereUniqueInput[] | OrganizationalUnitWhereUniqueInput
  >;
}

export interface ProcessingActivityUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  purpose?: Maybe<String>;
}

export interface ProcessingActivityCreateManyWithoutProcessInput {
  create?: Maybe<
    | ProcessingActivityCreateWithoutProcessInput[]
    | ProcessingActivityCreateWithoutProcessInput
  >;
  connect?: Maybe<
    ProcessingActivityWhereUniqueInput[] | ProcessingActivityWhereUniqueInput
  >;
}

export interface BusinessRoleUpdateOneWithoutProcessInput {
  create?: Maybe<BusinessRoleCreateWithoutProcessInput>;
  update?: Maybe<BusinessRoleUpdateWithoutProcessDataInput>;
  upsert?: Maybe<BusinessRoleUpsertWithoutProcessInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BusinessRoleWhereUniqueInput>;
}

export interface DataTypeCreateManyWithoutApplicationInput {
  create?: Maybe<
    | DataTypeCreateWithoutApplicationInput[]
    | DataTypeCreateWithoutApplicationInput
  >;
  connect?: Maybe<DataTypeWhereUniqueInput[] | DataTypeWhereUniqueInput>;
}

export interface BusinessRoleUpdateWithoutProcessDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
  person?: Maybe<PersonUpdateOneWithoutRolesInput>;
  organizationalUnit?: Maybe<
    OrganizationalUnitUpdateOneRequiredWithoutBusinessRolesInput
  >;
  appBusinessOwner?: Maybe<ApplicationUpdateManyWithoutBusinessOwnerInput>;
  appItOwner?: Maybe<ApplicationUpdateManyWithoutItOwnerInput>;
  appSecAdmin?: Maybe<ApplicationUpdateManyWithoutSecurityAdministratorInput>;
}

export interface ClassificationLabelCreateOneWithoutClassificationsInput {
  create?: Maybe<ClassificationLabelCreateWithoutClassificationsInput>;
  connect?: Maybe<ClassificationLabelWhereUniqueInput>;
}

export interface BusinessRoleUpsertWithoutProcessInput {
  update: BusinessRoleUpdateWithoutProcessDataInput;
  create: BusinessRoleCreateWithoutProcessInput;
}

export interface BusinessRoleCreateOneWithoutAppBusinessOwnerInput {
  create?: Maybe<BusinessRoleCreateWithoutAppBusinessOwnerInput>;
  connect?: Maybe<BusinessRoleWhereUniqueInput>;
}

export interface ProcessUpsertWithWhereUniqueWithoutOrganizationalUnitInput {
  where: ProcessWhereUniqueInput;
  update: ProcessUpdateWithoutOrganizationalUnitDataInput;
  create: ProcessCreateWithoutOrganizationalUnitInput;
}

export interface UserCreateOneWithoutPersonInput {
  create?: Maybe<UserCreateWithoutPersonInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface OrganizationalUnitUpsertWithWhereUniqueWithoutParentInput {
  where: OrganizationalUnitWhereUniqueInput;
  update: OrganizationalUnitUpdateWithoutParentDataInput;
  create: OrganizationalUnitCreateWithoutParentInput;
}

export interface OrganizationalUnitCreateWithoutBusinessRolesInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  children?: Maybe<OrganizationalUnitCreateManyWithoutParentInput>;
  parent?: Maybe<OrganizationalUnitCreateOneWithoutChildrenInput>;
  processes?: Maybe<ProcessCreateManyWithoutOrganizationalUnitInput>;
  organizationalUnitType?: Maybe<
    OrganizationalUnitTypeCreateOneWithoutOrganizationalUnitInput
  >;
}

export interface OrganizationalUnitScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    OrganizationalUnitScalarWhereInput[] | OrganizationalUnitScalarWhereInput
  >;
  OR?: Maybe<
    OrganizationalUnitScalarWhereInput[] | OrganizationalUnitScalarWhereInput
  >;
  NOT?: Maybe<
    OrganizationalUnitScalarWhereInput[] | OrganizationalUnitScalarWhereInput
  >;
}

export interface BusinessRoleCreateWithoutOrganizationalUnitInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
  person?: Maybe<PersonCreateOneWithoutRolesInput>;
  process?: Maybe<ProcessCreateManyWithoutProcessOwnerInput>;
  appBusinessOwner?: Maybe<ApplicationCreateManyWithoutBusinessOwnerInput>;
  appItOwner?: Maybe<ApplicationCreateManyWithoutItOwnerInput>;
  appSecAdmin?: Maybe<ApplicationCreateManyWithoutSecurityAdministratorInput>;
}

export interface OrganizationalUnitUpdateManyWithWhereNestedInput {
  where: OrganizationalUnitScalarWhereInput;
  data: OrganizationalUnitUpdateManyDataInput;
}

export interface ApplicationCreateWithoutBusinessOwnerInput {
  id?: Maybe<ID_Input>;
  name: String;
  alias?: Maybe<Json>;
  description?: Maybe<String>;
  processingActivities?: Maybe<
    ProcessingActivityCreateManyWithoutApplicationsInput
  >;
  dataType?: Maybe<DataTypeCreateManyWithoutApplicationInput>;
  itOwner?: Maybe<BusinessRoleCreateOneWithoutAppItOwnerInput>;
  securityAdministrator?: Maybe<BusinessRoleCreateOneWithoutAppSecAdminInput>;
}

export interface OrganizationalUnitUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ApplicationCreateWithoutSecurityAdministratorInput {
  id?: Maybe<ID_Input>;
  name: String;
  alias?: Maybe<Json>;
  description?: Maybe<String>;
  processingActivities?: Maybe<
    ProcessingActivityCreateManyWithoutApplicationsInput
  >;
  dataType?: Maybe<DataTypeCreateManyWithoutApplicationInput>;
  businessOwner?: Maybe<BusinessRoleCreateOneWithoutAppBusinessOwnerInput>;
  itOwner?: Maybe<BusinessRoleCreateOneWithoutAppItOwnerInput>;
}

export interface OrganizationalUnitUpsertWithoutProcessesInput {
  update: OrganizationalUnitUpdateWithoutProcessesDataInput;
  create: OrganizationalUnitCreateWithoutProcessesInput;
}

export interface ApplicationCreateWithoutItOwnerInput {
  id?: Maybe<ID_Input>;
  name: String;
  alias?: Maybe<Json>;
  description?: Maybe<String>;
  processingActivities?: Maybe<
    ProcessingActivityCreateManyWithoutApplicationsInput
  >;
  dataType?: Maybe<DataTypeCreateManyWithoutApplicationInput>;
  businessOwner?: Maybe<BusinessRoleCreateOneWithoutAppBusinessOwnerInput>;
  securityAdministrator?: Maybe<BusinessRoleCreateOneWithoutAppSecAdminInput>;
}

export interface ProcessUpsertWithoutProcessingActivitiesInput {
  update: ProcessUpdateWithoutProcessingActivitiesDataInput;
  create: ProcessCreateWithoutProcessingActivitiesInput;
}

export interface BusinessRoleCreateWithoutProcessInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
  person?: Maybe<PersonCreateOneWithoutRolesInput>;
  organizationalUnit: OrganizationalUnitCreateOneWithoutBusinessRolesInput;
  appBusinessOwner?: Maybe<ApplicationCreateManyWithoutBusinessOwnerInput>;
  appItOwner?: Maybe<ApplicationCreateManyWithoutItOwnerInput>;
  appSecAdmin?: Maybe<ApplicationCreateManyWithoutSecurityAdministratorInput>;
}

export interface ProcessingActivityUpsertWithWhereUniqueWithoutApplicationsInput {
  where: ProcessingActivityWhereUniqueInput;
  update: ProcessingActivityUpdateWithoutApplicationsDataInput;
  create: ProcessingActivityCreateWithoutApplicationsInput;
}

export interface ProcessingActivityUpdateWithoutApplicationsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  purpose?: Maybe<String>;
  process?: Maybe<ProcessUpdateOneWithoutProcessingActivitiesInput>;
}

export interface ApplicationUpdateManyMutationInput {
  name?: Maybe<String>;
  alias?: Maybe<Json>;
  description?: Maybe<String>;
}

export interface ClassificationLabelWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  score?: Maybe<Int>;
  score_not?: Maybe<Int>;
  score_in?: Maybe<Int[] | Int>;
  score_not_in?: Maybe<Int[] | Int>;
  score_lt?: Maybe<Int>;
  score_lte?: Maybe<Int>;
  score_gt?: Maybe<Int>;
  score_gte?: Maybe<Int>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  criteria?: Maybe<String>;
  criteria_not?: Maybe<String>;
  criteria_in?: Maybe<String[] | String>;
  criteria_not_in?: Maybe<String[] | String>;
  criteria_lt?: Maybe<String>;
  criteria_lte?: Maybe<String>;
  criteria_gt?: Maybe<String>;
  criteria_gte?: Maybe<String>;
  criteria_contains?: Maybe<String>;
  criteria_not_contains?: Maybe<String>;
  criteria_starts_with?: Maybe<String>;
  criteria_not_starts_with?: Maybe<String>;
  criteria_ends_with?: Maybe<String>;
  criteria_not_ends_with?: Maybe<String>;
  qualityAttribute?: Maybe<QualityAttributeWhereInput>;
  classifications_every?: Maybe<ClassificationWhereInput>;
  classifications_some?: Maybe<ClassificationWhereInput>;
  classifications_none?: Maybe<ClassificationWhereInput>;
  AND?: Maybe<ClassificationLabelWhereInput[] | ClassificationLabelWhereInput>;
  OR?: Maybe<ClassificationLabelWhereInput[] | ClassificationLabelWhereInput>;
  NOT?: Maybe<ClassificationLabelWhereInput[] | ClassificationLabelWhereInput>;
}

export interface OrganizationalUnitCreateWithoutOrganizationalUnitTypeInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  children?: Maybe<OrganizationalUnitCreateManyWithoutParentInput>;
  parent?: Maybe<OrganizationalUnitCreateOneWithoutChildrenInput>;
  processes?: Maybe<ProcessCreateManyWithoutOrganizationalUnitInput>;
  businessRoles?: Maybe<BusinessRoleCreateManyWithoutOrganizationalUnitInput>;
}

export interface ProcessSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProcessWhereInput>;
  AND?: Maybe<ProcessSubscriptionWhereInput[] | ProcessSubscriptionWhereInput>;
  OR?: Maybe<ProcessSubscriptionWhereInput[] | ProcessSubscriptionWhereInput>;
  NOT?: Maybe<ProcessSubscriptionWhereInput[] | ProcessSubscriptionWhereInput>;
}

export interface OrganizationalUnitCreateManyWithoutOrganizationalUnitTypeInput {
  create?: Maybe<
    | OrganizationalUnitCreateWithoutOrganizationalUnitTypeInput[]
    | OrganizationalUnitCreateWithoutOrganizationalUnitTypeInput
  >;
  connect?: Maybe<
    OrganizationalUnitWhereUniqueInput[] | OrganizationalUnitWhereUniqueInput
  >;
}

export interface ClassificationLabelSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClassificationLabelWhereInput>;
  AND?: Maybe<
    | ClassificationLabelSubscriptionWhereInput[]
    | ClassificationLabelSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ClassificationLabelSubscriptionWhereInput[]
    | ClassificationLabelSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ClassificationLabelSubscriptionWhereInput[]
    | ClassificationLabelSubscriptionWhereInput
  >;
}

export interface BusinessRoleCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
  person?: Maybe<PersonCreateOneWithoutRolesInput>;
  organizationalUnit: OrganizationalUnitCreateOneWithoutBusinessRolesInput;
  process?: Maybe<ProcessCreateManyWithoutProcessOwnerInput>;
  appBusinessOwner?: Maybe<ApplicationCreateManyWithoutBusinessOwnerInput>;
  appItOwner?: Maybe<ApplicationCreateManyWithoutItOwnerInput>;
  appSecAdmin?: Maybe<ApplicationCreateManyWithoutSecurityAdministratorInput>;
}

export interface PersonUpdateWithoutUserDataInput {
  name?: Maybe<String>;
  surname?: Maybe<String>;
  roles?: Maybe<BusinessRoleUpdateManyWithoutPersonInput>;
}

export interface BusinessRoleUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
  person?: Maybe<PersonUpdateOneWithoutRolesInput>;
  organizationalUnit?: Maybe<
    OrganizationalUnitUpdateOneRequiredWithoutBusinessRolesInput
  >;
  process?: Maybe<ProcessUpdateManyWithoutProcessOwnerInput>;
  appBusinessOwner?: Maybe<ApplicationUpdateManyWithoutBusinessOwnerInput>;
  appItOwner?: Maybe<ApplicationUpdateManyWithoutItOwnerInput>;
  appSecAdmin?: Maybe<ApplicationUpdateManyWithoutSecurityAdministratorInput>;
}

export interface QualityAttributeUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  appliesToObject?: Maybe<CLASSIFICATIONOBJECT>;
}

export interface BusinessRoleUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
}

export interface ClassificationLabelUpdateWithWhereUniqueWithoutQualityAttributeInput {
  where: ClassificationLabelWhereUniqueInput;
  data: ClassificationLabelUpdateWithoutQualityAttributeDataInput;
}

export interface ClassificationCreateInput {
  id?: Maybe<ID_Input>;
  dataType?: Maybe<DataTypeCreateOneWithoutClassificationsInput>;
  classificationLabel?: Maybe<
    ClassificationLabelCreateOneWithoutClassificationsInput
  >;
}

export interface ProcessingActivityUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  purpose?: Maybe<String>;
}

export interface DataTypeCreateOneWithoutClassificationsInput {
  create?: Maybe<DataTypeCreateWithoutClassificationsInput>;
  connect?: Maybe<DataTypeWhereUniqueInput>;
}

export type ProcessWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DataTypeCreateWithoutClassificationsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  application?: Maybe<ApplicationCreateManyWithoutDataTypeInput>;
}

export type QualityAttributeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ApplicationCreateManyWithoutDataTypeInput {
  create?: Maybe<
    | ApplicationCreateWithoutDataTypeInput[]
    | ApplicationCreateWithoutDataTypeInput
  >;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
}

export interface OrganizationalUnitUpdateWithWhereUniqueWithoutOrganizationalUnitTypeInput {
  where: OrganizationalUnitWhereUniqueInput;
  data: OrganizationalUnitUpdateWithoutOrganizationalUnitTypeDataInput;
}

export interface ApplicationCreateWithoutDataTypeInput {
  id?: Maybe<ID_Input>;
  name: String;
  alias?: Maybe<Json>;
  description?: Maybe<String>;
  processingActivities?: Maybe<
    ProcessingActivityCreateManyWithoutApplicationsInput
  >;
  businessOwner?: Maybe<BusinessRoleCreateOneWithoutAppBusinessOwnerInput>;
  itOwner?: Maybe<BusinessRoleCreateOneWithoutAppItOwnerInput>;
  securityAdministrator?: Maybe<BusinessRoleCreateOneWithoutAppSecAdminInput>;
}

export interface OrganizationalUnitCreateOneWithoutProcessesInput {
  create?: Maybe<OrganizationalUnitCreateWithoutProcessesInput>;
  connect?: Maybe<OrganizationalUnitWhereUniqueInput>;
}

export interface ClassificationUpdateInput {
  dataType?: Maybe<DataTypeUpdateOneWithoutClassificationsInput>;
  classificationLabel?: Maybe<
    ClassificationLabelUpdateOneWithoutClassificationsInput
  >;
}

export interface ApplicationCreateManyWithoutProcessingActivitiesInput {
  create?: Maybe<
    | ApplicationCreateWithoutProcessingActivitiesInput[]
    | ApplicationCreateWithoutProcessingActivitiesInput
  >;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
}

export interface DataTypeUpdateOneWithoutClassificationsInput {
  create?: Maybe<DataTypeCreateWithoutClassificationsInput>;
  update?: Maybe<DataTypeUpdateWithoutClassificationsDataInput>;
  upsert?: Maybe<DataTypeUpsertWithoutClassificationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DataTypeWhereUniqueInput>;
}

export interface QualityAttributeCreateOneWithoutClassificationLabelsInput {
  create?: Maybe<QualityAttributeCreateWithoutClassificationLabelsInput>;
  connect?: Maybe<QualityAttributeWhereUniqueInput>;
}

export interface DataTypeUpdateWithoutClassificationsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  application?: Maybe<ApplicationUpdateManyWithoutDataTypeInput>;
}

export interface UserCreatespecialPermissionsInput {
  set?: Maybe<PERMISSION[] | PERMISSION>;
}

export interface ApplicationUpdateManyWithoutDataTypeInput {
  create?: Maybe<
    | ApplicationCreateWithoutDataTypeInput[]
    | ApplicationCreateWithoutDataTypeInput
  >;
  delete?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  set?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  disconnect?: Maybe<
    ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput
  >;
  update?: Maybe<
    | ApplicationUpdateWithWhereUniqueWithoutDataTypeInput[]
    | ApplicationUpdateWithWhereUniqueWithoutDataTypeInput
  >;
  upsert?: Maybe<
    | ApplicationUpsertWithWhereUniqueWithoutDataTypeInput[]
    | ApplicationUpsertWithWhereUniqueWithoutDataTypeInput
  >;
  deleteMany?: Maybe<
    ApplicationScalarWhereInput[] | ApplicationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput
  >;
}

export interface ProcessCreateWithoutProcessOwnerInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  organizationalUnit?: Maybe<OrganizationalUnitCreateOneWithoutProcessesInput>;
  processingActivities?: Maybe<ProcessingActivityCreateManyWithoutProcessInput>;
}

export interface ApplicationUpdateWithWhereUniqueWithoutDataTypeInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutDataTypeDataInput;
}

export interface BusinessRoleCreateWithoutAppSecAdminInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
  person?: Maybe<PersonCreateOneWithoutRolesInput>;
  organizationalUnit: OrganizationalUnitCreateOneWithoutBusinessRolesInput;
  process?: Maybe<ProcessCreateManyWithoutProcessOwnerInput>;
  appBusinessOwner?: Maybe<ApplicationCreateManyWithoutBusinessOwnerInput>;
  appItOwner?: Maybe<ApplicationCreateManyWithoutItOwnerInput>;
}

export interface ApplicationUpdateWithoutDataTypeDataInput {
  name?: Maybe<String>;
  alias?: Maybe<Json>;
  description?: Maybe<String>;
  processingActivities?: Maybe<
    ProcessingActivityUpdateManyWithoutApplicationsInput
  >;
  businessOwner?: Maybe<BusinessRoleUpdateOneWithoutAppBusinessOwnerInput>;
  itOwner?: Maybe<BusinessRoleUpdateOneWithoutAppItOwnerInput>;
  securityAdministrator?: Maybe<BusinessRoleUpdateOneWithoutAppSecAdminInput>;
}

export interface ProcessingActivityUpdateManyWithoutApplicationsInput {
  create?: Maybe<
    | ProcessingActivityCreateWithoutApplicationsInput[]
    | ProcessingActivityCreateWithoutApplicationsInput
  >;
  delete?: Maybe<
    ProcessingActivityWhereUniqueInput[] | ProcessingActivityWhereUniqueInput
  >;
  connect?: Maybe<
    ProcessingActivityWhereUniqueInput[] | ProcessingActivityWhereUniqueInput
  >;
  set?: Maybe<
    ProcessingActivityWhereUniqueInput[] | ProcessingActivityWhereUniqueInput
  >;
  disconnect?: Maybe<
    ProcessingActivityWhereUniqueInput[] | ProcessingActivityWhereUniqueInput
  >;
  update?: Maybe<
    | ProcessingActivityUpdateWithWhereUniqueWithoutApplicationsInput[]
    | ProcessingActivityUpdateWithWhereUniqueWithoutApplicationsInput
  >;
  upsert?: Maybe<
    | ProcessingActivityUpsertWithWhereUniqueWithoutApplicationsInput[]
    | ProcessingActivityUpsertWithWhereUniqueWithoutApplicationsInput
  >;
  deleteMany?: Maybe<
    ProcessingActivityScalarWhereInput[] | ProcessingActivityScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProcessingActivityUpdateManyWithWhereNestedInput[]
    | ProcessingActivityUpdateManyWithWhereNestedInput
  >;
}

export interface ApplicationUpsertWithWhereUniqueWithoutDataTypeInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutDataTypeDataInput;
  create: ApplicationCreateWithoutDataTypeInput;
}

export interface QualityAttributeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QualityAttributeWhereInput>;
  AND?: Maybe<
    | QualityAttributeSubscriptionWhereInput[]
    | QualityAttributeSubscriptionWhereInput
  >;
  OR?: Maybe<
    | QualityAttributeSubscriptionWhereInput[]
    | QualityAttributeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | QualityAttributeSubscriptionWhereInput[]
    | QualityAttributeSubscriptionWhereInput
  >;
}

export interface DataTypeUpsertWithoutClassificationsInput {
  update: DataTypeUpdateWithoutClassificationsDataInput;
  create: DataTypeCreateWithoutClassificationsInput;
}

export interface ApplicationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ApplicationWhereInput>;
  AND?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
  OR?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
}

export interface ClassificationLabelCreateInput {
  id?: Maybe<ID_Input>;
  score: Int;
  label: String;
  criteria?: Maybe<String>;
  qualityAttribute?: Maybe<
    QualityAttributeCreateOneWithoutClassificationLabelsInput
  >;
  classifications?: Maybe<
    ClassificationCreateManyWithoutClassificationLabelInput
  >;
}

export interface ClassificationLabelScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  score?: Maybe<Int>;
  score_not?: Maybe<Int>;
  score_in?: Maybe<Int[] | Int>;
  score_not_in?: Maybe<Int[] | Int>;
  score_lt?: Maybe<Int>;
  score_lte?: Maybe<Int>;
  score_gt?: Maybe<Int>;
  score_gte?: Maybe<Int>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  criteria?: Maybe<String>;
  criteria_not?: Maybe<String>;
  criteria_in?: Maybe<String[] | String>;
  criteria_not_in?: Maybe<String[] | String>;
  criteria_lt?: Maybe<String>;
  criteria_lte?: Maybe<String>;
  criteria_gt?: Maybe<String>;
  criteria_gte?: Maybe<String>;
  criteria_contains?: Maybe<String>;
  criteria_not_contains?: Maybe<String>;
  criteria_starts_with?: Maybe<String>;
  criteria_not_starts_with?: Maybe<String>;
  criteria_ends_with?: Maybe<String>;
  criteria_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ClassificationLabelScalarWhereInput[] | ClassificationLabelScalarWhereInput
  >;
  OR?: Maybe<
    ClassificationLabelScalarWhereInput[] | ClassificationLabelScalarWhereInput
  >;
  NOT?: Maybe<
    ClassificationLabelScalarWhereInput[] | ClassificationLabelScalarWhereInput
  >;
}

export interface ClassificationCreateManyWithoutClassificationLabelInput {
  create?: Maybe<
    | ClassificationCreateWithoutClassificationLabelInput[]
    | ClassificationCreateWithoutClassificationLabelInput
  >;
  connect?: Maybe<
    ClassificationWhereUniqueInput[] | ClassificationWhereUniqueInput
  >;
}

export interface ProcessingActivityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  purpose?: Maybe<String>;
  purpose_not?: Maybe<String>;
  purpose_in?: Maybe<String[] | String>;
  purpose_not_in?: Maybe<String[] | String>;
  purpose_lt?: Maybe<String>;
  purpose_lte?: Maybe<String>;
  purpose_gt?: Maybe<String>;
  purpose_gte?: Maybe<String>;
  purpose_contains?: Maybe<String>;
  purpose_not_contains?: Maybe<String>;
  purpose_starts_with?: Maybe<String>;
  purpose_not_starts_with?: Maybe<String>;
  purpose_ends_with?: Maybe<String>;
  purpose_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  process?: Maybe<ProcessWhereInput>;
  applications_every?: Maybe<ApplicationWhereInput>;
  applications_some?: Maybe<ApplicationWhereInput>;
  applications_none?: Maybe<ApplicationWhereInput>;
  AND?: Maybe<ProcessingActivityWhereInput[] | ProcessingActivityWhereInput>;
  OR?: Maybe<ProcessingActivityWhereInput[] | ProcessingActivityWhereInput>;
  NOT?: Maybe<ProcessingActivityWhereInput[] | ProcessingActivityWhereInput>;
}

export interface ClassificationCreateWithoutClassificationLabelInput {
  id?: Maybe<ID_Input>;
  dataType?: Maybe<DataTypeCreateOneWithoutClassificationsInput>;
}

export interface OrganizationalUnitTypeUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  reportingUnit?: Maybe<Boolean>;
}

export interface ClassificationLabelUpdateInput {
  score?: Maybe<Int>;
  label?: Maybe<String>;
  criteria?: Maybe<String>;
  qualityAttribute?: Maybe<
    QualityAttributeUpdateOneWithoutClassificationLabelsInput
  >;
  classifications?: Maybe<
    ClassificationUpdateManyWithoutClassificationLabelInput
  >;
}

export interface ProcessCreateManyWithoutOrganizationalUnitInput {
  create?: Maybe<
    | ProcessCreateWithoutOrganizationalUnitInput[]
    | ProcessCreateWithoutOrganizationalUnitInput
  >;
  connect?: Maybe<ProcessWhereUniqueInput[] | ProcessWhereUniqueInput>;
}

export interface ClassificationUpdateManyWithoutClassificationLabelInput {
  create?: Maybe<
    | ClassificationCreateWithoutClassificationLabelInput[]
    | ClassificationCreateWithoutClassificationLabelInput
  >;
  delete?: Maybe<
    ClassificationWhereUniqueInput[] | ClassificationWhereUniqueInput
  >;
  connect?: Maybe<
    ClassificationWhereUniqueInput[] | ClassificationWhereUniqueInput
  >;
  set?: Maybe<
    ClassificationWhereUniqueInput[] | ClassificationWhereUniqueInput
  >;
  disconnect?: Maybe<
    ClassificationWhereUniqueInput[] | ClassificationWhereUniqueInput
  >;
  update?: Maybe<
    | ClassificationUpdateWithWhereUniqueWithoutClassificationLabelInput[]
    | ClassificationUpdateWithWhereUniqueWithoutClassificationLabelInput
  >;
  upsert?: Maybe<
    | ClassificationUpsertWithWhereUniqueWithoutClassificationLabelInput[]
    | ClassificationUpsertWithWhereUniqueWithoutClassificationLabelInput
  >;
  deleteMany?: Maybe<
    ClassificationScalarWhereInput[] | ClassificationScalarWhereInput
  >;
}

export interface PersonCreateOneWithoutRolesInput {
  create?: Maybe<PersonCreateWithoutRolesInput>;
  connect?: Maybe<PersonWhereUniqueInput>;
}

export interface ClassificationUpdateWithWhereUniqueWithoutClassificationLabelInput {
  where: ClassificationWhereUniqueInput;
  data: ClassificationUpdateWithoutClassificationLabelDataInput;
}

export interface BusinessRoleCreateWithoutAppItOwnerInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  raciPrivacy?: Maybe<RACI>;
  raciSecurity?: Maybe<RACI>;
  raciFinancial?: Maybe<RACI>;
  raciExecutive?: Maybe<RACI>;
  person?: Maybe<PersonCreateOneWithoutRolesInput>;
  organizationalUnit: OrganizationalUnitCreateOneWithoutBusinessRolesInput;
  process?: Maybe<ProcessCreateManyWithoutProcessOwnerInput>;
  appBusinessOwner?: Maybe<ApplicationCreateManyWithoutBusinessOwnerInput>;
  appSecAdmin?: Maybe<ApplicationCreateManyWithoutSecurityAdministratorInput>;
}

export interface ClassificationUpdateWithoutClassificationLabelDataInput {
  dataType?: Maybe<DataTypeUpdateOneWithoutClassificationsInput>;
}

export interface ProcessUpdateWithoutProcessingActivitiesDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  organizationalUnit?: Maybe<OrganizationalUnitUpdateOneWithoutProcessesInput>;
  processOwner?: Maybe<BusinessRoleUpdateOneWithoutProcessInput>;
}

export interface ClassificationUpsertWithWhereUniqueWithoutClassificationLabelInput {
  where: ClassificationWhereUniqueInput;
  update: ClassificationUpdateWithoutClassificationLabelDataInput;
  create: ClassificationCreateWithoutClassificationLabelInput;
}

export interface PersonCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  name: String;
  surname?: Maybe<String>;
  roles?: Maybe<BusinessRoleCreateManyWithoutPersonInput>;
}

export interface ClassificationLabelUpdateManyMutationInput {
  score?: Maybe<Int>;
  label?: Maybe<String>;
  criteria?: Maybe<String>;
}

export type ProcessingActivityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DataTypeCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  application?: Maybe<ApplicationCreateManyWithoutDataTypeInput>;
  classifications?: Maybe<ClassificationCreateManyWithoutDataTypeInput>;
}

export interface ClassificationCreateManyWithoutDataTypeInput {
  create?: Maybe<
    | ClassificationCreateWithoutDataTypeInput[]
    | ClassificationCreateWithoutDataTypeInput
  >;
  connect?: Maybe<
    ClassificationWhereUniqueInput[] | ClassificationWhereUniqueInput
  >;
}

export interface DataTypeUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  application?: Maybe<ApplicationUpdateManyWithoutDataTypeInput>;
  classifications?: Maybe<ClassificationUpdateManyWithoutDataTypeInput>;
}

export interface OrganizationalUnitTypeCreateWithoutOrganizationalUnitInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  reportingUnit?: Maybe<Boolean>;
}

export interface OrganizationalUnitUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface OrganizationalUnitUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  children?: Maybe<OrganizationalUnitUpdateManyWithoutParentInput>;
  parent?: Maybe<OrganizationalUnitUpdateOneWithoutChildrenInput>;
  processes?: Maybe<ProcessUpdateManyWithoutOrganizationalUnitInput>;
  businessRoles?: Maybe<BusinessRoleUpdateManyWithoutOrganizationalUnitInput>;
  organizationalUnitType?: Maybe<
    OrganizationalUnitTypeUpdateOneWithoutOrganizationalUnitInput
  >;
}

export interface OrganizationalUnitCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  children?: Maybe<OrganizationalUnitCreateManyWithoutParentInput>;
  parent?: Maybe<OrganizationalUnitCreateOneWithoutChildrenInput>;
  processes?: Maybe<ProcessCreateManyWithoutOrganizationalUnitInput>;
  businessRoles?: Maybe<BusinessRoleCreateManyWithoutOrganizationalUnitInput>;
  organizationalUnitType?: Maybe<
    OrganizationalUnitTypeCreateOneWithoutOrganizationalUnitInput
  >;
}

export interface DataTypeUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  person?: Maybe<PersonWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface OrganizationalUnitCreateWithoutChildrenInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  parent?: Maybe<OrganizationalUnitCreateOneWithoutChildrenInput>;
  processes?: Maybe<ProcessCreateManyWithoutOrganizationalUnitInput>;
  businessRoles?: Maybe<BusinessRoleCreateManyWithoutOrganizationalUnitInput>;
  organizationalUnitType?: Maybe<
    OrganizationalUnitTypeCreateOneWithoutOrganizationalUnitInput
  >;
}

export interface ProcessingActivityCreateManyWithoutApplicationsInput {
  create?: Maybe<
    | ProcessingActivityCreateWithoutApplicationsInput[]
    | ProcessingActivityCreateWithoutApplicationsInput
  >;
  connect?: Maybe<
    ProcessingActivityWhereUniqueInput[] | ProcessingActivityWhereUniqueInput
  >;
}

export interface ClassificationLabelCreateWithoutQualityAttributeInput {
  id?: Maybe<ID_Input>;
  score: Int;
  label: String;
  criteria?: Maybe<String>;
  classifications?: Maybe<
    ClassificationCreateManyWithoutClassificationLabelInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  active?: Boolean;
  specialPermissions: PERMISSION[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  active: () => Promise<Boolean>;
  specialPermissions: () => Promise<PERMISSION[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  specialPermissions: () => Promise<AsyncIterator<PERMISSION[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BusinessRoleEdge {
  node: BusinessRole;
  cursor: String;
}

export interface BusinessRoleEdgePromise
  extends Promise<BusinessRoleEdge>,
    Fragmentable {
  node: <T = BusinessRolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BusinessRoleEdgeSubscription
  extends Promise<AsyncIterator<BusinessRoleEdge>>,
    Fragmentable {
  node: <T = BusinessRoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProcessingActivityPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  purpose?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProcessingActivityPreviousValuesPromise
  extends Promise<ProcessingActivityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  purpose: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProcessingActivityPreviousValuesSubscription
  extends Promise<AsyncIterator<ProcessingActivityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  purpose: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BusinessRoleConnection {
  pageInfo: PageInfo;
  edges: BusinessRoleEdge[];
}

export interface BusinessRoleConnectionPromise
  extends Promise<BusinessRoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BusinessRoleEdge>>() => T;
  aggregate: <T = AggregateBusinessRolePromise>() => T;
}

export interface BusinessRoleConnectionSubscription
  extends Promise<AsyncIterator<BusinessRoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BusinessRoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBusinessRoleSubscription>() => T;
}

export interface ApplicationEdge {
  node: Application;
  cursor: String;
}

export interface ApplicationEdgePromise
  extends Promise<ApplicationEdge>,
    Fragmentable {
  node: <T = ApplicationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ApplicationEdgeSubscription
  extends Promise<AsyncIterator<ApplicationEdge>>,
    Fragmentable {
  node: <T = ApplicationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateApplication {
  count: Int;
}

export interface AggregateApplicationPromise
  extends Promise<AggregateApplication>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateApplicationSubscription
  extends Promise<AsyncIterator<AggregateApplication>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQualityAttribute {
  count: Int;
}

export interface AggregateQualityAttributePromise
  extends Promise<AggregateQualityAttribute>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQualityAttributeSubscription
  extends Promise<AsyncIterator<AggregateQualityAttribute>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ApplicationConnection {
  pageInfo: PageInfo;
  edges: ApplicationEdge[];
}

export interface ApplicationConnectionPromise
  extends Promise<ApplicationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ApplicationEdge>>() => T;
  aggregate: <T = AggregateApplicationPromise>() => T;
}

export interface ApplicationConnectionSubscription
  extends Promise<AsyncIterator<ApplicationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ApplicationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateApplicationSubscription>() => T;
}

export interface QualityAttributeConnection {
  pageInfo: PageInfo;
  edges: QualityAttributeEdge[];
}

export interface QualityAttributeConnectionPromise
  extends Promise<QualityAttributeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QualityAttributeEdge>>() => T;
  aggregate: <T = AggregateQualityAttributePromise>() => T;
}

export interface QualityAttributeConnectionSubscription
  extends Promise<AsyncIterator<QualityAttributeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QualityAttributeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQualityAttributeSubscription>() => T;
}

export interface QualityAttribute {
  id: ID_Output;
  name: String;
  description?: String;
  appliesToObject: CLASSIFICATIONOBJECT;
}

export interface QualityAttributePromise
  extends Promise<QualityAttribute>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  appliesToObject: () => Promise<CLASSIFICATIONOBJECT>;
  classificationLabels: <T = FragmentableArray<ClassificationLabel>>(args?: {
    where?: ClassificationLabelWhereInput;
    orderBy?: ClassificationLabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QualityAttributeSubscription
  extends Promise<AsyncIterator<QualityAttribute>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  appliesToObject: () => Promise<AsyncIterator<CLASSIFICATIONOBJECT>>;
  classificationLabels: <
    T = Promise<AsyncIterator<ClassificationLabelSubscription>>
  >(args?: {
    where?: ClassificationLabelWhereInput;
    orderBy?: ClassificationLabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QualityAttributeNullablePromise
  extends Promise<QualityAttribute | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  appliesToObject: () => Promise<CLASSIFICATIONOBJECT>;
  classificationLabels: <T = FragmentableArray<ClassificationLabel>>(args?: {
    where?: ClassificationLabelWhereInput;
    orderBy?: ClassificationLabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateProcessingActivity {
  count: Int;
}

export interface AggregateProcessingActivityPromise
  extends Promise<AggregateProcessingActivity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProcessingActivitySubscription
  extends Promise<AsyncIterator<AggregateProcessingActivity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Application {
  id: ID_Output;
  name: String;
  alias?: Json;
  description?: String;
}

export interface ApplicationPromise extends Promise<Application>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  alias: () => Promise<Json>;
  description: () => Promise<String>;
  processingActivities: <T = FragmentableArray<ProcessingActivity>>(args?: {
    where?: ProcessingActivityWhereInput;
    orderBy?: ProcessingActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dataType: <T = FragmentableArray<DataType>>(args?: {
    where?: DataTypeWhereInput;
    orderBy?: DataTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  businessOwner: <T = BusinessRolePromise>() => T;
  itOwner: <T = BusinessRolePromise>() => T;
  securityAdministrator: <T = BusinessRolePromise>() => T;
}

export interface ApplicationSubscription
  extends Promise<AsyncIterator<Application>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  alias: () => Promise<AsyncIterator<Json>>;
  description: () => Promise<AsyncIterator<String>>;
  processingActivities: <
    T = Promise<AsyncIterator<ProcessingActivitySubscription>>
  >(args?: {
    where?: ProcessingActivityWhereInput;
    orderBy?: ProcessingActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dataType: <T = Promise<AsyncIterator<DataTypeSubscription>>>(args?: {
    where?: DataTypeWhereInput;
    orderBy?: DataTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  businessOwner: <T = BusinessRoleSubscription>() => T;
  itOwner: <T = BusinessRoleSubscription>() => T;
  securityAdministrator: <T = BusinessRoleSubscription>() => T;
}

export interface ApplicationNullablePromise
  extends Promise<Application | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  alias: () => Promise<Json>;
  description: () => Promise<String>;
  processingActivities: <T = FragmentableArray<ProcessingActivity>>(args?: {
    where?: ProcessingActivityWhereInput;
    orderBy?: ProcessingActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dataType: <T = FragmentableArray<DataType>>(args?: {
    where?: DataTypeWhereInput;
    orderBy?: DataTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  businessOwner: <T = BusinessRolePromise>() => T;
  itOwner: <T = BusinessRolePromise>() => T;
  securityAdministrator: <T = BusinessRolePromise>() => T;
}

export interface ProcessingActivityConnection {
  pageInfo: PageInfo;
  edges: ProcessingActivityEdge[];
}

export interface ProcessingActivityConnectionPromise
  extends Promise<ProcessingActivityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProcessingActivityEdge>>() => T;
  aggregate: <T = AggregateProcessingActivityPromise>() => T;
}

export interface ProcessingActivityConnectionSubscription
  extends Promise<AsyncIterator<ProcessingActivityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProcessingActivityEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProcessingActivitySubscription>() => T;
}

export interface ApplicationSubscriptionPayload {
  mutation: MutationType;
  node: Application;
  updatedFields: String[];
  previousValues: ApplicationPreviousValues;
}

export interface ApplicationSubscriptionPayloadPromise
  extends Promise<ApplicationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ApplicationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ApplicationPreviousValuesPromise>() => T;
}

export interface ApplicationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ApplicationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ApplicationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ApplicationPreviousValuesSubscription>() => T;
}

export interface ProcessEdge {
  node: Process;
  cursor: String;
}

export interface ProcessEdgePromise extends Promise<ProcessEdge>, Fragmentable {
  node: <T = ProcessPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProcessEdgeSubscription
  extends Promise<AsyncIterator<ProcessEdge>>,
    Fragmentable {
  node: <T = ProcessSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ApplicationPreviousValues {
  id: ID_Output;
  name: String;
  alias?: Json;
  description?: String;
}

export interface ApplicationPreviousValuesPromise
  extends Promise<ApplicationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  alias: () => Promise<Json>;
  description: () => Promise<String>;
}

export interface ApplicationPreviousValuesSubscription
  extends Promise<AsyncIterator<ApplicationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  alias: () => Promise<AsyncIterator<Json>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePerson {
  count: Int;
}

export interface AggregatePersonPromise
  extends Promise<AggregatePerson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePersonSubscription
  extends Promise<AsyncIterator<AggregatePerson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClassificationLabel {
  id: ID_Output;
  score: Int;
  label: String;
  criteria?: String;
}

export interface ClassificationLabelPromise
  extends Promise<ClassificationLabel>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  score: () => Promise<Int>;
  label: () => Promise<String>;
  criteria: () => Promise<String>;
  qualityAttribute: <T = QualityAttributePromise>() => T;
  classifications: <T = FragmentableArray<Classification>>(args?: {
    where?: ClassificationWhereInput;
    orderBy?: ClassificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ClassificationLabelSubscription
  extends Promise<AsyncIterator<ClassificationLabel>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  score: () => Promise<AsyncIterator<Int>>;
  label: () => Promise<AsyncIterator<String>>;
  criteria: () => Promise<AsyncIterator<String>>;
  qualityAttribute: <T = QualityAttributeSubscription>() => T;
  classifications: <
    T = Promise<AsyncIterator<ClassificationSubscription>>
  >(args?: {
    where?: ClassificationWhereInput;
    orderBy?: ClassificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ClassificationLabelNullablePromise
  extends Promise<ClassificationLabel | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  score: () => Promise<Int>;
  label: () => Promise<String>;
  criteria: () => Promise<String>;
  qualityAttribute: <T = QualityAttributePromise>() => T;
  classifications: <T = FragmentableArray<Classification>>(args?: {
    where?: ClassificationWhereInput;
    orderBy?: ClassificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PersonConnection {
  pageInfo: PageInfo;
  edges: PersonEdge[];
}

export interface PersonConnectionPromise
  extends Promise<PersonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PersonEdge>>() => T;
  aggregate: <T = AggregatePersonPromise>() => T;
}

export interface PersonConnectionSubscription
  extends Promise<AsyncIterator<PersonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PersonEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePersonSubscription>() => T;
}

export interface BusinessRoleSubscriptionPayload {
  mutation: MutationType;
  node: BusinessRole;
  updatedFields: String[];
  previousValues: BusinessRolePreviousValues;
}

export interface BusinessRoleSubscriptionPayloadPromise
  extends Promise<BusinessRoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BusinessRolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BusinessRolePreviousValuesPromise>() => T;
}

export interface BusinessRoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BusinessRoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BusinessRoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BusinessRolePreviousValuesSubscription>() => T;
}

export interface OrganizationalUnitTypeEdge {
  node: OrganizationalUnitType;
  cursor: String;
}

export interface OrganizationalUnitTypeEdgePromise
  extends Promise<OrganizationalUnitTypeEdge>,
    Fragmentable {
  node: <T = OrganizationalUnitTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrganizationalUnitTypeEdgeSubscription
  extends Promise<AsyncIterator<OrganizationalUnitTypeEdge>>,
    Fragmentable {
  node: <T = OrganizationalUnitTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BusinessRolePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  raciPrivacy?: RACI;
  raciSecurity?: RACI;
  raciFinancial?: RACI;
  raciExecutive?: RACI;
}

export interface BusinessRolePreviousValuesPromise
  extends Promise<BusinessRolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  raciPrivacy: () => Promise<RACI>;
  raciSecurity: () => Promise<RACI>;
  raciFinancial: () => Promise<RACI>;
  raciExecutive: () => Promise<RACI>;
}

export interface BusinessRolePreviousValuesSubscription
  extends Promise<AsyncIterator<BusinessRolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  raciPrivacy: () => Promise<AsyncIterator<RACI>>;
  raciSecurity: () => Promise<AsyncIterator<RACI>>;
  raciFinancial: () => Promise<AsyncIterator<RACI>>;
  raciExecutive: () => Promise<AsyncIterator<RACI>>;
}

export interface QualityAttributeSubscriptionPayload {
  mutation: MutationType;
  node: QualityAttribute;
  updatedFields: String[];
  previousValues: QualityAttributePreviousValues;
}

export interface QualityAttributeSubscriptionPayloadPromise
  extends Promise<QualityAttributeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QualityAttributePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QualityAttributePreviousValuesPromise>() => T;
}

export interface QualityAttributeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QualityAttributeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QualityAttributeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QualityAttributePreviousValuesSubscription>() => T;
}

export interface Classification {
  id: ID_Output;
}

export interface ClassificationPromise
  extends Promise<Classification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dataType: <T = DataTypePromise>() => T;
  classificationLabel: <T = ClassificationLabelPromise>() => T;
}

export interface ClassificationSubscription
  extends Promise<AsyncIterator<Classification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dataType: <T = DataTypeSubscription>() => T;
  classificationLabel: <T = ClassificationLabelSubscription>() => T;
}

export interface ClassificationNullablePromise
  extends Promise<Classification | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dataType: <T = DataTypePromise>() => T;
  classificationLabel: <T = ClassificationLabelPromise>() => T;
}

export interface OrganizationalUnitEdge {
  node: OrganizationalUnit;
  cursor: String;
}

export interface OrganizationalUnitEdgePromise
  extends Promise<OrganizationalUnitEdge>,
    Fragmentable {
  node: <T = OrganizationalUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrganizationalUnitEdgeSubscription
  extends Promise<AsyncIterator<OrganizationalUnitEdge>>,
    Fragmentable {
  node: <T = OrganizationalUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ClassificationSubscriptionPayload {
  mutation: MutationType;
  node: Classification;
  updatedFields: String[];
  previousValues: ClassificationPreviousValues;
}

export interface ClassificationSubscriptionPayloadPromise
  extends Promise<ClassificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClassificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClassificationPreviousValuesPromise>() => T;
}

export interface ClassificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClassificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClassificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClassificationPreviousValuesSubscription>() => T;
}

export interface AggregateDataType {
  count: Int;
}

export interface AggregateDataTypePromise
  extends Promise<AggregateDataType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDataTypeSubscription
  extends Promise<AsyncIterator<AggregateDataType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClassificationPreviousValues {
  id: ID_Output;
}

export interface ClassificationPreviousValuesPromise
  extends Promise<ClassificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ClassificationPreviousValuesSubscription
  extends Promise<AsyncIterator<ClassificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface DataTypeConnection {
  pageInfo: PageInfo;
  edges: DataTypeEdge[];
}

export interface DataTypeConnectionPromise
  extends Promise<DataTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DataTypeEdge>>() => T;
  aggregate: <T = AggregateDataTypePromise>() => T;
}

export interface DataTypeConnectionSubscription
  extends Promise<AsyncIterator<DataTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DataTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDataTypeSubscription>() => T;
}

export interface DataType {
  id: ID_Output;
  name: String;
  description?: String;
}

export interface DataTypePromise extends Promise<DataType>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  application: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classifications: <T = FragmentableArray<Classification>>(args?: {
    where?: ClassificationWhereInput;
    orderBy?: ClassificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DataTypeSubscription
  extends Promise<AsyncIterator<DataType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  application: <T = Promise<AsyncIterator<ApplicationSubscription>>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classifications: <
    T = Promise<AsyncIterator<ClassificationSubscription>>
  >(args?: {
    where?: ClassificationWhereInput;
    orderBy?: ClassificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DataTypeNullablePromise
  extends Promise<DataType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  application: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classifications: <T = FragmentableArray<Classification>>(args?: {
    where?: ClassificationWhereInput;
    orderBy?: ClassificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ClassificationLabelEdge {
  node: ClassificationLabel;
  cursor: String;
}

export interface ClassificationLabelEdgePromise
  extends Promise<ClassificationLabelEdge>,
    Fragmentable {
  node: <T = ClassificationLabelPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClassificationLabelEdgeSubscription
  extends Promise<AsyncIterator<ClassificationLabelEdge>>,
    Fragmentable {
  node: <T = ClassificationLabelSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ClassificationLabelSubscriptionPayload {
  mutation: MutationType;
  node: ClassificationLabel;
  updatedFields: String[];
  previousValues: ClassificationLabelPreviousValues;
}

export interface ClassificationLabelSubscriptionPayloadPromise
  extends Promise<ClassificationLabelSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClassificationLabelPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClassificationLabelPreviousValuesPromise>() => T;
}

export interface ClassificationLabelSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClassificationLabelSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClassificationLabelSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClassificationLabelPreviousValuesSubscription>() => T;
}

export interface AggregateClassification {
  count: Int;
}

export interface AggregateClassificationPromise
  extends Promise<AggregateClassification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClassificationSubscription
  extends Promise<AsyncIterator<AggregateClassification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClassificationLabelPreviousValues {
  id: ID_Output;
  score: Int;
  label: String;
  criteria?: String;
}

export interface ClassificationLabelPreviousValuesPromise
  extends Promise<ClassificationLabelPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  score: () => Promise<Int>;
  label: () => Promise<String>;
  criteria: () => Promise<String>;
}

export interface ClassificationLabelPreviousValuesSubscription
  extends Promise<AsyncIterator<ClassificationLabelPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  score: () => Promise<AsyncIterator<Int>>;
  label: () => Promise<AsyncIterator<String>>;
  criteria: () => Promise<AsyncIterator<String>>;
}

export interface ClassificationConnection {
  pageInfo: PageInfo;
  edges: ClassificationEdge[];
}

export interface ClassificationConnectionPromise
  extends Promise<ClassificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClassificationEdge>>() => T;
  aggregate: <T = AggregateClassificationPromise>() => T;
}

export interface ClassificationConnectionSubscription
  extends Promise<AsyncIterator<ClassificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClassificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClassificationSubscription>() => T;
}

export interface OrganizationalUnitType {
  id: ID_Output;
  name: String;
  description?: String;
  reportingUnit?: Boolean;
}

export interface OrganizationalUnitTypePromise
  extends Promise<OrganizationalUnitType>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  reportingUnit: () => Promise<Boolean>;
  organizationalUnit: <T = FragmentableArray<OrganizationalUnit>>(args?: {
    where?: OrganizationalUnitWhereInput;
    orderBy?: OrganizationalUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OrganizationalUnitTypeSubscription
  extends Promise<AsyncIterator<OrganizationalUnitType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  reportingUnit: () => Promise<AsyncIterator<Boolean>>;
  organizationalUnit: <
    T = Promise<AsyncIterator<OrganizationalUnitSubscription>>
  >(args?: {
    where?: OrganizationalUnitWhereInput;
    orderBy?: OrganizationalUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OrganizationalUnitTypeNullablePromise
  extends Promise<OrganizationalUnitType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  reportingUnit: () => Promise<Boolean>;
  organizationalUnit: <T = FragmentableArray<OrganizationalUnit>>(args?: {
    where?: OrganizationalUnitWhereInput;
    orderBy?: OrganizationalUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface DataTypeSubscriptionPayload {
  mutation: MutationType;
  node: DataType;
  updatedFields: String[];
  previousValues: DataTypePreviousValues;
}

export interface DataTypeSubscriptionPayloadPromise
  extends Promise<DataTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DataTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DataTypePreviousValuesPromise>() => T;
}

export interface DataTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DataTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DataTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DataTypePreviousValuesSubscription>() => T;
}

export interface ProcessingActivity {
  id: ID_Output;
  name: String;
  description?: String;
  purpose?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProcessingActivityPromise
  extends Promise<ProcessingActivity>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  purpose: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  process: <T = ProcessPromise>() => T;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProcessingActivitySubscription
  extends Promise<AsyncIterator<ProcessingActivity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  purpose: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  process: <T = ProcessSubscription>() => T;
  applications: <T = Promise<AsyncIterator<ApplicationSubscription>>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProcessingActivityNullablePromise
  extends Promise<ProcessingActivity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  purpose: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  process: <T = ProcessPromise>() => T;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DataTypePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
}

export interface DataTypePreviousValuesPromise
  extends Promise<DataTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface DataTypePreviousValuesSubscription
  extends Promise<AsyncIterator<DataTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface QualityAttributePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  appliesToObject: CLASSIFICATIONOBJECT;
}

export interface QualityAttributePreviousValuesPromise
  extends Promise<QualityAttributePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  appliesToObject: () => Promise<CLASSIFICATIONOBJECT>;
}

export interface QualityAttributePreviousValuesSubscription
  extends Promise<AsyncIterator<QualityAttributePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  appliesToObject: () => Promise<AsyncIterator<CLASSIFICATIONOBJECT>>;
}

export interface User {
  id: ID_Output;
  email: String;
  password: String;
  active?: Boolean;
  specialPermissions: PERMISSION[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  active: () => Promise<Boolean>;
  specialPermissions: () => Promise<PERMISSION[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  person: <T = PersonPromise>() => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  specialPermissions: () => Promise<AsyncIterator<PERMISSION[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  person: <T = PersonSubscription>() => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  active: () => Promise<Boolean>;
  specialPermissions: () => Promise<PERMISSION[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  person: <T = PersonPromise>() => T;
}

export interface AggregateProcess {
  count: Int;
}

export interface AggregateProcessPromise
  extends Promise<AggregateProcess>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProcessSubscription
  extends Promise<AsyncIterator<AggregateProcess>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrganizationalUnitSubscriptionPayload {
  mutation: MutationType;
  node: OrganizationalUnit;
  updatedFields: String[];
  previousValues: OrganizationalUnitPreviousValues;
}

export interface OrganizationalUnitSubscriptionPayloadPromise
  extends Promise<OrganizationalUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrganizationalUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrganizationalUnitPreviousValuesPromise>() => T;
}

export interface OrganizationalUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrganizationalUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrganizationalUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrganizationalUnitPreviousValuesSubscription>() => T;
}

export interface PersonEdge {
  node: Person;
  cursor: String;
}

export interface PersonEdgePromise extends Promise<PersonEdge>, Fragmentable {
  node: <T = PersonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PersonEdgeSubscription
  extends Promise<AsyncIterator<PersonEdge>>,
    Fragmentable {
  node: <T = PersonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrganizationalUnitPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OrganizationalUnitPreviousValuesPromise
  extends Promise<OrganizationalUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrganizationalUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<OrganizationalUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OrganizationalUnitTypeConnection {
  pageInfo: PageInfo;
  edges: OrganizationalUnitTypeEdge[];
}

export interface OrganizationalUnitTypeConnectionPromise
  extends Promise<OrganizationalUnitTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrganizationalUnitTypeEdge>>() => T;
  aggregate: <T = AggregateOrganizationalUnitTypePromise>() => T;
}

export interface OrganizationalUnitTypeConnectionSubscription
  extends Promise<AsyncIterator<OrganizationalUnitTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<OrganizationalUnitTypeEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateOrganizationalUnitTypeSubscription>() => T;
}

export interface Person {
  id: ID_Output;
  name: String;
  surname?: String;
}

export interface PersonPromise extends Promise<Person>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  surname: () => Promise<String>;
  user: <T = UserPromise>() => T;
  roles: <T = FragmentableArray<BusinessRole>>(args?: {
    where?: BusinessRoleWhereInput;
    orderBy?: BusinessRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PersonSubscription
  extends Promise<AsyncIterator<Person>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  surname: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  roles: <T = Promise<AsyncIterator<BusinessRoleSubscription>>>(args?: {
    where?: BusinessRoleWhereInput;
    orderBy?: BusinessRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PersonNullablePromise
  extends Promise<Person | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  surname: () => Promise<String>;
  user: <T = UserPromise>() => T;
  roles: <T = FragmentableArray<BusinessRole>>(args?: {
    where?: BusinessRoleWhereInput;
    orderBy?: BusinessRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OrganizationalUnitConnection {
  pageInfo: PageInfo;
  edges: OrganizationalUnitEdge[];
}

export interface OrganizationalUnitConnectionPromise
  extends Promise<OrganizationalUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrganizationalUnitEdge>>() => T;
  aggregate: <T = AggregateOrganizationalUnitPromise>() => T;
}

export interface OrganizationalUnitConnectionSubscription
  extends Promise<AsyncIterator<OrganizationalUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<OrganizationalUnitEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateOrganizationalUnitSubscription>() => T;
}

export interface OrganizationalUnitTypeSubscriptionPayload {
  mutation: MutationType;
  node: OrganizationalUnitType;
  updatedFields: String[];
  previousValues: OrganizationalUnitTypePreviousValues;
}

export interface OrganizationalUnitTypeSubscriptionPayloadPromise
  extends Promise<OrganizationalUnitTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrganizationalUnitTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrganizationalUnitTypePreviousValuesPromise>() => T;
}

export interface OrganizationalUnitTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrganizationalUnitTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrganizationalUnitTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrganizationalUnitTypePreviousValuesSubscription>() => T;
}

export interface AggregateClassificationLabel {
  count: Int;
}

export interface AggregateClassificationLabelPromise
  extends Promise<AggregateClassificationLabel>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClassificationLabelSubscription
  extends Promise<AsyncIterator<AggregateClassificationLabel>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrganizationalUnitTypePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  reportingUnit?: Boolean;
}

export interface OrganizationalUnitTypePreviousValuesPromise
  extends Promise<OrganizationalUnitTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  reportingUnit: () => Promise<Boolean>;
}

export interface OrganizationalUnitTypePreviousValuesSubscription
  extends Promise<AsyncIterator<OrganizationalUnitTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  reportingUnit: () => Promise<AsyncIterator<Boolean>>;
}

export interface ClassificationEdge {
  node: Classification;
  cursor: String;
}

export interface ClassificationEdgePromise
  extends Promise<ClassificationEdge>,
    Fragmentable {
  node: <T = ClassificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClassificationEdgeSubscription
  extends Promise<AsyncIterator<ClassificationEdge>>,
    Fragmentable {
  node: <T = ClassificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BusinessRole {
  id: ID_Output;
  name: String;
  description?: String;
  raciPrivacy?: RACI;
  raciSecurity?: RACI;
  raciFinancial?: RACI;
  raciExecutive?: RACI;
}

export interface BusinessRolePromise
  extends Promise<BusinessRole>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  raciPrivacy: () => Promise<RACI>;
  raciSecurity: () => Promise<RACI>;
  raciFinancial: () => Promise<RACI>;
  raciExecutive: () => Promise<RACI>;
  person: <T = PersonPromise>() => T;
  organizationalUnit: <T = OrganizationalUnitPromise>() => T;
  process: <T = FragmentableArray<Process>>(args?: {
    where?: ProcessWhereInput;
    orderBy?: ProcessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  appBusinessOwner: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  appItOwner: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  appSecAdmin: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BusinessRoleSubscription
  extends Promise<AsyncIterator<BusinessRole>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  raciPrivacy: () => Promise<AsyncIterator<RACI>>;
  raciSecurity: () => Promise<AsyncIterator<RACI>>;
  raciFinancial: () => Promise<AsyncIterator<RACI>>;
  raciExecutive: () => Promise<AsyncIterator<RACI>>;
  person: <T = PersonSubscription>() => T;
  organizationalUnit: <T = OrganizationalUnitSubscription>() => T;
  process: <T = Promise<AsyncIterator<ProcessSubscription>>>(args?: {
    where?: ProcessWhereInput;
    orderBy?: ProcessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  appBusinessOwner: <
    T = Promise<AsyncIterator<ApplicationSubscription>>
  >(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  appItOwner: <T = Promise<AsyncIterator<ApplicationSubscription>>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  appSecAdmin: <T = Promise<AsyncIterator<ApplicationSubscription>>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BusinessRoleNullablePromise
  extends Promise<BusinessRole | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  raciPrivacy: () => Promise<RACI>;
  raciSecurity: () => Promise<RACI>;
  raciFinancial: () => Promise<RACI>;
  raciExecutive: () => Promise<RACI>;
  person: <T = PersonPromise>() => T;
  organizationalUnit: <T = OrganizationalUnitPromise>() => T;
  process: <T = FragmentableArray<Process>>(args?: {
    where?: ProcessWhereInput;
    orderBy?: ProcessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  appBusinessOwner: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  appItOwner: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  appSecAdmin: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PersonSubscriptionPayload {
  mutation: MutationType;
  node: Person;
  updatedFields: String[];
  previousValues: PersonPreviousValues;
}

export interface PersonSubscriptionPayloadPromise
  extends Promise<PersonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PersonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PersonPreviousValuesPromise>() => T;
}

export interface PersonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PersonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PersonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PersonPreviousValuesSubscription>() => T;
}

export interface ProcessingActivityEdge {
  node: ProcessingActivity;
  cursor: String;
}

export interface ProcessingActivityEdgePromise
  extends Promise<ProcessingActivityEdge>,
    Fragmentable {
  node: <T = ProcessingActivityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProcessingActivityEdgeSubscription
  extends Promise<AsyncIterator<ProcessingActivityEdge>>,
    Fragmentable {
  node: <T = ProcessingActivitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PersonPreviousValues {
  id: ID_Output;
  name: String;
  surname?: String;
}

export interface PersonPreviousValuesPromise
  extends Promise<PersonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  surname: () => Promise<String>;
}

export interface PersonPreviousValuesSubscription
  extends Promise<AsyncIterator<PersonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  surname: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrganizationalUnitType {
  count: Int;
}

export interface AggregateOrganizationalUnitTypePromise
  extends Promise<AggregateOrganizationalUnitType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrganizationalUnitTypeSubscription
  extends Promise<AsyncIterator<AggregateOrganizationalUnitType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Process {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProcessPromise extends Promise<Process>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  organizationalUnit: <T = OrganizationalUnitPromise>() => T;
  processingActivities: <T = FragmentableArray<ProcessingActivity>>(args?: {
    where?: ProcessingActivityWhereInput;
    orderBy?: ProcessingActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  processOwner: <T = BusinessRolePromise>() => T;
}

export interface ProcessSubscription
  extends Promise<AsyncIterator<Process>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  organizationalUnit: <T = OrganizationalUnitSubscription>() => T;
  processingActivities: <
    T = Promise<AsyncIterator<ProcessingActivitySubscription>>
  >(args?: {
    where?: ProcessingActivityWhereInput;
    orderBy?: ProcessingActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  processOwner: <T = BusinessRoleSubscription>() => T;
}

export interface ProcessNullablePromise
  extends Promise<Process | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  organizationalUnit: <T = OrganizationalUnitPromise>() => T;
  processingActivities: <T = FragmentableArray<ProcessingActivity>>(args?: {
    where?: ProcessingActivityWhereInput;
    orderBy?: ProcessingActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  processOwner: <T = BusinessRolePromise>() => T;
}

export interface DataTypeEdge {
  node: DataType;
  cursor: String;
}

export interface DataTypeEdgePromise
  extends Promise<DataTypeEdge>,
    Fragmentable {
  node: <T = DataTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DataTypeEdgeSubscription
  extends Promise<AsyncIterator<DataTypeEdge>>,
    Fragmentable {
  node: <T = DataTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBusinessRole {
  count: Int;
}

export interface AggregateBusinessRolePromise
  extends Promise<AggregateBusinessRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBusinessRoleSubscription
  extends Promise<AsyncIterator<AggregateBusinessRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProcessingActivitySubscriptionPayload {
  mutation: MutationType;
  node: ProcessingActivity;
  updatedFields: String[];
  previousValues: ProcessingActivityPreviousValues;
}

export interface ProcessingActivitySubscriptionPayloadPromise
  extends Promise<ProcessingActivitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProcessingActivityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProcessingActivityPreviousValuesPromise>() => T;
}

export interface ProcessingActivitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProcessingActivitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProcessingActivitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProcessingActivityPreviousValuesSubscription>() => T;
}

export interface OrganizationalUnit {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OrganizationalUnitPromise
  extends Promise<OrganizationalUnit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  children: <T = FragmentableArray<OrganizationalUnit>>(args?: {
    where?: OrganizationalUnitWhereInput;
    orderBy?: OrganizationalUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = OrganizationalUnitPromise>() => T;
  processes: <T = FragmentableArray<Process>>(args?: {
    where?: ProcessWhereInput;
    orderBy?: ProcessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  businessRoles: <T = FragmentableArray<BusinessRole>>(args?: {
    where?: BusinessRoleWhereInput;
    orderBy?: BusinessRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  organizationalUnitType: <T = OrganizationalUnitTypePromise>() => T;
}

export interface OrganizationalUnitSubscription
  extends Promise<AsyncIterator<OrganizationalUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  children: <
    T = Promise<AsyncIterator<OrganizationalUnitSubscription>>
  >(args?: {
    where?: OrganizationalUnitWhereInput;
    orderBy?: OrganizationalUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = OrganizationalUnitSubscription>() => T;
  processes: <T = Promise<AsyncIterator<ProcessSubscription>>>(args?: {
    where?: ProcessWhereInput;
    orderBy?: ProcessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  businessRoles: <T = Promise<AsyncIterator<BusinessRoleSubscription>>>(args?: {
    where?: BusinessRoleWhereInput;
    orderBy?: BusinessRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  organizationalUnitType: <T = OrganizationalUnitTypeSubscription>() => T;
}

export interface OrganizationalUnitNullablePromise
  extends Promise<OrganizationalUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  children: <T = FragmentableArray<OrganizationalUnit>>(args?: {
    where?: OrganizationalUnitWhereInput;
    orderBy?: OrganizationalUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = OrganizationalUnitPromise>() => T;
  processes: <T = FragmentableArray<Process>>(args?: {
    where?: ProcessWhereInput;
    orderBy?: ProcessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  businessRoles: <T = FragmentableArray<BusinessRole>>(args?: {
    where?: BusinessRoleWhereInput;
    orderBy?: BusinessRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  organizationalUnitType: <T = OrganizationalUnitTypePromise>() => T;
}

export interface ProcessPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProcessPreviousValuesPromise
  extends Promise<ProcessPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProcessPreviousValuesSubscription
  extends Promise<AsyncIterator<ProcessPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProcessSubscriptionPayload {
  mutation: MutationType;
  node: Process;
  updatedFields: String[];
  previousValues: ProcessPreviousValues;
}

export interface ProcessSubscriptionPayloadPromise
  extends Promise<ProcessSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProcessPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProcessPreviousValuesPromise>() => T;
}

export interface ProcessSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProcessSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProcessSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProcessPreviousValuesSubscription>() => T;
}

export interface QualityAttributeEdge {
  node: QualityAttribute;
  cursor: String;
}

export interface QualityAttributeEdgePromise
  extends Promise<QualityAttributeEdge>,
    Fragmentable {
  node: <T = QualityAttributePromise>() => T;
  cursor: () => Promise<String>;
}

export interface QualityAttributeEdgeSubscription
  extends Promise<AsyncIterator<QualityAttributeEdge>>,
    Fragmentable {
  node: <T = QualityAttributeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ClassificationLabelConnection {
  pageInfo: PageInfo;
  edges: ClassificationLabelEdge[];
}

export interface ClassificationLabelConnectionPromise
  extends Promise<ClassificationLabelConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClassificationLabelEdge>>() => T;
  aggregate: <T = AggregateClassificationLabelPromise>() => T;
}

export interface ClassificationLabelConnectionSubscription
  extends Promise<AsyncIterator<ClassificationLabelConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ClassificationLabelEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateClassificationLabelSubscription>() => T;
}

export interface AggregateOrganizationalUnit {
  count: Int;
}

export interface AggregateOrganizationalUnitPromise
  extends Promise<AggregateOrganizationalUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrganizationalUnitSubscription
  extends Promise<AsyncIterator<AggregateOrganizationalUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProcessConnection {
  pageInfo: PageInfo;
  edges: ProcessEdge[];
}

export interface ProcessConnectionPromise
  extends Promise<ProcessConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProcessEdge>>() => T;
  aggregate: <T = AggregateProcessPromise>() => T;
}

export interface ProcessConnectionSubscription
  extends Promise<AsyncIterator<ProcessConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProcessEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProcessSubscription>() => T;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

export type Json = any;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "PERMISSION",
    embedded: false
  },
  {
    name: "RACI",
    embedded: false
  },
  {
    name: "CLASSIFICATIONOBJECT",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Person",
    embedded: false
  },
  {
    name: "BusinessRole",
    embedded: false
  },
  {
    name: "OrganizationalUnit",
    embedded: false
  },
  {
    name: "OrganizationalUnitType",
    embedded: false
  },
  {
    name: "Process",
    embedded: false
  },
  {
    name: "ProcessingActivity",
    embedded: false
  },
  {
    name: "Application",
    embedded: false
  },
  {
    name: "DataType",
    embedded: false
  },
  {
    name: "Classification",
    embedded: false
  },
  {
    name: "QualityAttribute",
    embedded: false
  },
  {
    name: "ClassificationLabel",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://us1.prisma.sh/hans-petervanriemsdijk-b37eac/abc_gdpr/dev`
});
export const prisma = new Prisma();
